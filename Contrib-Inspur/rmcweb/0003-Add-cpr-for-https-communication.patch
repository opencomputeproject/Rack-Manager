From a5e47b4fd0f17935820d3b7a9062c510fed60e50 Mon Sep 17 00:00:00 2001
From: John Wang <wangzqbj@inspur.com>
Date: Tue, 5 Mar 2019 15:38:34 +0800
Subject: [PATCH 3/4] Add cpr for https communication

Signed-off-by: John Wang <wangzqbj@inspur.com>
---
 cpr/.clang-format               |   59 ++
 cpr/.gitignore                  |   45 ++
 cpr/.gitmodules                 |    9 +
 cpr/.travis.yml                 |  125 ++++
 cpr/AUTHORS                     |   32 +
 cpr/CMakeLists.txt              |   81 +++
 cpr/CONTRIBUTING.md             |   27 +
 cpr/LICENSE                     |   21 +
 cpr/README.md                   |   96 +++
 cpr/VERSION                     |    1 +
 cpr/appveyor.yml                |   16 +
 cpr/cpr-config.cmake            |   26 +
 cpr/cpr/CMakeLists.txt          |   55 ++
 cpr/cpr/auth.cpp                |    9 +
 cpr/cpr/cookies.cpp             |   30 +
 cpr/cpr/cprtypes.cpp            |   14 +
 cpr/cpr/digest.cpp              |    9 +
 cpr/cpr/error.cpp               |   62 ++
 cpr/cpr/multipart.cpp           |    7 +
 cpr/cpr/parameters.cpp          |   30 +
 cpr/cpr/payload.cpp             |   20 +
 cpr/cpr/proxies.cpp             |   21 +
 cpr/cpr/session.cpp             |  477 +++++++++++++
 cpr/cpr/ssl_options.cpp         |   11 +
 cpr/cpr/timeout.cpp             |   26 +
 cpr/cpr/util.cpp                |   81 +++
 cpr/format-check.sh             |   37 +
 cpr/include/cpr/api.h           |  200 ++++++
 cpr/include/cpr/auth.h          |   27 +
 cpr/include/cpr/body.h          |   35 +
 cpr/include/cpr/cookies.h       |   26 +
 cpr/include/cpr/cpr.h           |   10 +
 cpr/include/cpr/cprtypes.h      |   18 +
 cpr/include/cpr/curlholder.h    |   19 +
 cpr/include/cpr/defines.h       |    8 +
 cpr/include/cpr/digest.h        |   20 +
 cpr/include/cpr/error.h         |   53 ++
 cpr/include/cpr/low_speed.h     |   18 +
 cpr/include/cpr/max_redirects.h |   18 +
 cpr/include/cpr/multipart.h     |   75 ++
 cpr/include/cpr/parameters.h    |   33 +
 cpr/include/cpr/payload.h       |   43 ++
 cpr/include/cpr/proxies.h       |   25 +
 cpr/include/cpr/response.h      |   38 +
 cpr/include/cpr/session.h       |   87 +++
 cpr/include/cpr/ssl_options.h   |   19 +
 cpr/include/cpr/timeout.h       |   21 +
 cpr/include/cpr/util.h          |   20 +
 cpr/opt/CMakeLists.txt          |  115 +++
 cpr/test/CMakeLists.txt         |   51 ++
 cpr/test/alternating_tests.cpp  |  164 +++++
 cpr/test/async_tests.cpp        |   65 ++
 cpr/test/callback_tests.cpp     |  730 +++++++++++++++++++
 cpr/test/delete_tests.cpp       |  260 +++++++
 cpr/test/error_tests.cpp        |   96 +++
 cpr/test/get_tests.cpp          | 1178 +++++++++++++++++++++++++++++++
 cpr/test/head_tests.cpp         |  203 ++++++
 cpr/test/options_tests.cpp      |   78 ++
 cpr/test/patch_tests.cpp        |  270 +++++++
 cpr/test/post_tests.cpp         |  365 ++++++++++
 cpr/test/proxy_tests.cpp        |   94 +++
 cpr/test/put_tests.cpp          |  270 +++++++
 cpr/test/raw_body_tests.cpp     |  134 ++++
 cpr/test/server.cpp             |  701 ++++++++++++++++++
 cpr/test/server.h               |   21 +
 cpr/test/session_tests.cpp      |  776 ++++++++++++++++++++
 cpr/test/util_tests.cpp         |   78 ++
 src/cpr_test.cpp                |    9 +
 68 files changed, 7898 insertions(+)
 create mode 100644 cpr/.clang-format
 create mode 100644 cpr/.gitignore
 create mode 100644 cpr/.gitmodules
 create mode 100644 cpr/.travis.yml
 create mode 100644 cpr/AUTHORS
 create mode 100644 cpr/CMakeLists.txt
 create mode 100644 cpr/CONTRIBUTING.md
 create mode 100644 cpr/LICENSE
 create mode 100644 cpr/README.md
 create mode 100644 cpr/VERSION
 create mode 100644 cpr/appveyor.yml
 create mode 100644 cpr/cpr-config.cmake
 create mode 100644 cpr/cpr/CMakeLists.txt
 create mode 100644 cpr/cpr/auth.cpp
 create mode 100644 cpr/cpr/cookies.cpp
 create mode 100644 cpr/cpr/cprtypes.cpp
 create mode 100644 cpr/cpr/digest.cpp
 create mode 100644 cpr/cpr/error.cpp
 create mode 100644 cpr/cpr/multipart.cpp
 create mode 100644 cpr/cpr/parameters.cpp
 create mode 100644 cpr/cpr/payload.cpp
 create mode 100644 cpr/cpr/proxies.cpp
 create mode 100644 cpr/cpr/session.cpp
 create mode 100644 cpr/cpr/ssl_options.cpp
 create mode 100644 cpr/cpr/timeout.cpp
 create mode 100644 cpr/cpr/util.cpp
 create mode 100755 cpr/format-check.sh
 create mode 100644 cpr/include/cpr/api.h
 create mode 100644 cpr/include/cpr/auth.h
 create mode 100644 cpr/include/cpr/body.h
 create mode 100644 cpr/include/cpr/cookies.h
 create mode 100644 cpr/include/cpr/cpr.h
 create mode 100644 cpr/include/cpr/cprtypes.h
 create mode 100644 cpr/include/cpr/curlholder.h
 create mode 100644 cpr/include/cpr/defines.h
 create mode 100644 cpr/include/cpr/digest.h
 create mode 100644 cpr/include/cpr/error.h
 create mode 100644 cpr/include/cpr/low_speed.h
 create mode 100644 cpr/include/cpr/max_redirects.h
 create mode 100644 cpr/include/cpr/multipart.h
 create mode 100644 cpr/include/cpr/parameters.h
 create mode 100644 cpr/include/cpr/payload.h
 create mode 100644 cpr/include/cpr/proxies.h
 create mode 100644 cpr/include/cpr/response.h
 create mode 100644 cpr/include/cpr/session.h
 create mode 100644 cpr/include/cpr/ssl_options.h
 create mode 100644 cpr/include/cpr/timeout.h
 create mode 100644 cpr/include/cpr/util.h
 create mode 100644 cpr/opt/CMakeLists.txt
 create mode 100644 cpr/test/CMakeLists.txt
 create mode 100644 cpr/test/alternating_tests.cpp
 create mode 100644 cpr/test/async_tests.cpp
 create mode 100644 cpr/test/callback_tests.cpp
 create mode 100644 cpr/test/delete_tests.cpp
 create mode 100644 cpr/test/error_tests.cpp
 create mode 100644 cpr/test/get_tests.cpp
 create mode 100644 cpr/test/head_tests.cpp
 create mode 100644 cpr/test/options_tests.cpp
 create mode 100644 cpr/test/patch_tests.cpp
 create mode 100644 cpr/test/post_tests.cpp
 create mode 100644 cpr/test/proxy_tests.cpp
 create mode 100644 cpr/test/put_tests.cpp
 create mode 100644 cpr/test/raw_body_tests.cpp
 create mode 100644 cpr/test/server.cpp
 create mode 100644 cpr/test/server.h
 create mode 100644 cpr/test/session_tests.cpp
 create mode 100644 cpr/test/util_tests.cpp
 create mode 100644 src/cpr_test.cpp

diff --git a/cpr/.clang-format b/cpr/.clang-format
new file mode 100644
index 0000000..2dda09e
--- /dev/null
+++ b/cpr/.clang-format
@@ -0,0 +1,59 @@
+---
+Language:        Cpp
+# BasedOnStyle:  Google
+AccessModifierOffset: -2
+AlignAfterOpenBracket: true
+AlignEscapedNewlinesLeft: true
+AlignOperands: true
+AlignTrailingComments: true
+AllowAllParametersOfDeclarationOnNextLine: true
+AllowShortBlocksOnASingleLine: false
+AllowShortCaseLabelsOnASingleLine: false
+AllowShortIfStatementsOnASingleLine: false
+AllowShortLoopsOnASingleLine: false
+AllowShortFunctionsOnASingleLine: Empty
+AlwaysBreakAfterDefinitionReturnType: false
+AlwaysBreakTemplateDeclarations: true
+AlwaysBreakBeforeMultilineStrings: true
+BreakBeforeBinaryOperators: None
+BreakBeforeTernaryOperators: true
+BreakConstructorInitializersBeforeComma: false
+BinPackParameters: true
+BinPackArguments: true
+ColumnLimit: 100
+ConstructorInitializerAllOnOneLineOrOnePerLine: false
+ConstructorInitializerIndentWidth: 8
+DerivePointerAlignment: false
+ExperimentalAutoDetectBinPacking: false
+IndentCaseLabels: true
+IndentWrappedFunctionNames: false
+IndentFunctionDeclarationAfterType: false
+MaxEmptyLinesToKeep: 2
+KeepEmptyLinesAtTheStartOfBlocks: false
+NamespaceIndentation: None
+PenaltyBreakBeforeFirstCallParameter: 1
+PenaltyBreakComment: 300
+PenaltyBreakString: 1000
+PenaltyBreakFirstLessLess: 120
+PenaltyExcessCharacter: 1000000
+PenaltyReturnTypeOnItsOwnLine: 200
+PointerAlignment: Left
+SpacesBeforeTrailingComments: 1
+Cpp11BracedListStyle: true
+Standard:        Auto
+IndentWidth:     4
+TabWidth:        8
+UseTab:          Never
+BreakBeforeBraces: Attach
+SpacesInParentheses: false
+SpacesInSquareBrackets: false
+SpacesInAngles:  false
+SpaceInEmptyParentheses: false
+SpacesInCStyleCastParentheses: false
+SpaceAfterCStyleCast: true
+SpacesInContainerLiterals: true
+SpaceBeforeAssignmentOperators: true
+ContinuationIndentWidth: 8
+CommentPragmas:  '^ IWYU pragma:'
+SpaceBeforeParens: ControlStatements
+...
diff --git a/cpr/.gitignore b/cpr/.gitignore
new file mode 100644
index 0000000..bedd5ad
--- /dev/null
+++ b/cpr/.gitignore
@@ -0,0 +1,45 @@
+# Compiled Object files
+*.slo
+*.lo
+*.o
+*.obj
+
+# Precompiled Headers
+*.gch
+*.pch
+
+# Compiled Dynamic libraries
+*.so
+*.dylib
+*.dll
+
+# Fortran module files
+*.mod
+
+# Compiled Static libraries
+*.lai
+*.la
+*.a
+*.lib
+
+# Executables
+*.exe
+*.out
+*.app
+
+# CMake
+CMakeCache.txt
+CMakeFiles
+Makefile
+cmake_install.cmake
+install_manifest.txt
+
+# Custom
+build/
+
+# Jekyll stuff
+_includes/
+_site/
+
+# Vim
+.ycm_extra_conf.py*
diff --git a/cpr/.gitmodules b/cpr/.gitmodules
new file mode 100644
index 0000000..cd5d5ba
--- /dev/null
+++ b/cpr/.gitmodules
@@ -0,0 +1,9 @@
+[submodule "opt/curl"]
+	path = opt/curl
+	url = https://github.com/whoshuu/curl.git
+[submodule "opt/googletest"]
+	path = opt/googletest
+	url = https://github.com/whoshuu/googletest.git
+[submodule "opt/mongoose"]
+	path = opt/mongoose
+	url = https://github.com/whoshuu/mongoose.git
diff --git a/cpr/.travis.yml b/cpr/.travis.yml
new file mode 100644
index 0000000..93d471f
--- /dev/null
+++ b/cpr/.travis.yml
@@ -0,0 +1,125 @@
+language: cpp
+
+sudo: false
+cache: ccache
+
+compiler: clang
+
+# gcc 4.9 default
+addons: &addons
+  apt:
+    packages: &packages
+      - g++-4.9
+      - clang-format-3.8
+      - python-pip
+    sources: &sources
+      - ubuntu-toolchain-r-test
+      - llvm-toolchain-precise-3.5
+      - llvm-toolchain-precise-3.6
+      - llvm-toolchain-precise-3.7
+      - llvm-toolchain-precise-3.8
+
+env:
+  global:
+    - BUILD_CPR_TESTS=ON
+    - GTEST_SHUFFLE=1
+    - USE_SYSTEM_CURL=ON
+  matrix:
+    - COMPILER=g++-4.9 CCOMPILER=gcc-4.9 GENERATE_COVERAGE=ON FORMAT_CHECK=ON
+
+matrix:
+  include:
+    # gcc 4.6
+    - env: COMPILER=g++-4.6 CCOMPILER=gcc-4.6
+      addons:
+        apt:
+          packages: g++-4.6
+          sources: *sources
+
+    # gcc 4.7
+    - env: COMPILER=g++-4.7 CCOMPILER=gcc-4.7 EXTRA_CXXFLAGS=-D_GLIBCXX_USE_NANOSLEEP
+      addons:
+        apt:
+          packages: g++-4.7
+          sources: *sources
+
+    # gcc 4.8
+    - env: COMPILER=g++-4.8 CCOMPILER=gcc-4.8
+      addons:
+        apt:
+          packages: g++-4.8
+          sources: *sources
+
+    # gcc 5
+    - env: COMPILER=g++-5 CCOMPILER=gcc-5
+      addons:
+        apt:
+          packages: g++-5
+          sources: *sources
+
+    # Clang 3.4
+    - env: COMPILER=clang++ CCOMPILER=clang LINUX_CLANG=1
+      addons:
+        apt:
+          packages: clang-3.4
+          sources: *sources
+
+    # Clang 3.5
+    - env: COMPILER=clang++-3.5 CCOMPILER=clang-3.5
+      addons:
+        apt:
+          packages: clang-3.5
+          sources: *sources
+
+    # Clang 3.6
+    - env: COMPILER=clang++-3.6 CCOMPILER=clang-3.6
+      addons:
+        apt:
+          packages: clang-3.6
+          sources: *sources
+
+    # Clang 3.7
+    - env: COMPILER=clang++-3.7 CCOMPILER=clang-3.7
+      addons:
+        apt:
+          packages: clang-3.7
+          sources: *sources
+
+    # Clang 3.8
+    - env: COMPILER=clang++-3.8 CCOMPILER=clang-3.8
+      addons:
+        apt:
+          packages: clang-3.8
+          sources: *sources
+
+    # Xcode 6.4
+    - os: osx
+      env: COMPILER=clang++ CCOMPILER=clang
+      osx_image: xcode6.4
+
+    # Xcode 7
+    - os: osx
+      env: COMPILER=clang++ CCOMPILER=clang
+      osx_image: xcode7
+  allow_failures:
+    - env: COMPILER=g++-4.6 CCOMPILER=gcc-4.6
+    - env: COMPILER=clang++ CCOMPILER=clang LINUX_CLANG=1
+
+install:
+  - if [ "$GENERATE_COVERAGE" == "ON" ]; then pip install --user git+git://github.com/eddyxu/cpp-coveralls.git; fi
+
+before_script:
+  - export CXX=$COMPILER CC=$CCOMPILER
+  - export CXXFLAGS=$EXTRA_CXXFLAGS
+  - cmake --version
+  - mkdir build
+  - cd build
+  - cmake -LAH ..
+
+script:
+  - make -j2 VERBOSE=1
+  - ctest -V
+  - if [ "$FORMAT_CHECK" == "ON" ]; then cd ${TRAVIS_BUILD_DIR} && ./format-check.sh; fi
+
+after_success:
+  - if [ "$GENERATE_COVERAGE" == "ON" ]; then cd ${TRAVIS_BUILD_DIR}/build && coveralls -i 'cpr' -i 'include' -e '../include/cpr.h' --root '../' --verbose --gcov-options '\-lp' --gcov 'gcov-4.9'; fi
diff --git a/cpr/AUTHORS b/cpr/AUTHORS
new file mode 100644
index 0000000..32eac49
--- /dev/null
+++ b/cpr/AUTHORS
@@ -0,0 +1,32 @@
+Adam Nielsen <adam.nielsen@uq.edu.au>
+Andreas Gerstmayr <andreas.gerstmayr@gmail.com>
+Anton Lindstr√∂m <lindztr@gmail.com>
+bandzaw <bandzaw@gmail.com>
+Bob Jansen <bobjansen@gmail.com>
+Chase Geigle <sky@skystrife.com>
+Danilo Spinella <danyspin.ds@gmail.com>
+David E <hdak1945git@users.noreply.github.com>
+Don Goodman-Wilson <don@slack-corp.com>
+Eren Okka <erenokka@gmail.com>
+Felix Vanorder <Felix.Vanorder@gmail.com>
+Florian Dang <florian.dang@qhedgetech.com>
+fuchs <cf@fos4x.de>
+Guo Xiao <guoxiao08@gmail.com>
+Himanshu Shekhar <himanshub16@users.noreply.github.com>
+Huu Nguyen <whoshuu@gmail.com>
+Ivan Smirnov <i.s.smirnov@gmail.com>
+Josh Leeb-du Toit <josh.leebdutoit@gmail.com>
+Klaus Silveira <contact@klaussilveira.com>
+Mexus <gilaldpellaeon@gmail.com>
+nabijaczleweli <nabijaczleweli@gmail.com>
+noh4h_ss <noh4hss@gmail.com>
+Omer Katz <omer.drow@gmail.com>
+pravic <ehysta@gmail.com>
+Sam Bristow <sam.bristow@gmail.com>
+Sean Chittenden <seanc@groupon.com>
+Shuyu Liang <thinkingene@gmail.com>
+Simon Ninon <simon.ninon@gmail.com>
+Smiley Barry <smiley@users.noreply.github.com>
+Vittorio Romeo <vittorio.romeo@outlook.com>
+Vladimir Gamalian <vladimir.gamalian@gmail.com>
+xpol <xpolife@gmail.com>
diff --git a/cpr/CMakeLists.txt b/cpr/CMakeLists.txt
new file mode 100644
index 0000000..c138364
--- /dev/null
+++ b/cpr/CMakeLists.txt
@@ -0,0 +1,81 @@
+cmake_minimum_required(VERSION 2.8.7)
+
+if(POLICY CMP0048)
+    # cmake warns if loaded from a min-3.0-required parent dir, so silence the warning:
+    cmake_policy(SET CMP0048 NEW)
+endif()
+
+# Allow use of project folders for IDEs like Visual Studio, so we
+# could organize projects into relevant folders: "cpr", "tests" & "external (libraries)".
+set_property(GLOBAL PROPERTY USE_FOLDERS ON)
+set_property(GLOBAL PROPERTY PREDEFINED_TARGETS_FOLDER "CMake")
+
+project(cpr CXX)
+
+if(NOT ${CMAKE_VERSION} LESS 3.2)
+    set(CMAKE_CXX_STANDARD 11)
+    set(CMAKE_CXX_STANDARD_REQUIRED ON)
+else()
+    message(STATUS "Checking compiler flags for C++11 support.")
+    # Set C++11 support flags for various compilers
+    include(CheckCXXCompilerFlag)
+    check_cxx_compiler_flag("-std=c++11" COMPILER_SUPPORTS_CXX11)
+    check_cxx_compiler_flag("-std=c++0x" COMPILER_SUPPORTS_CXX0X)
+    if(COMPILER_SUPPORTS_CXX11)
+        message(STATUS "C++11 is supported.")
+        if(${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
+            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -stdlib=libc++")
+        else()
+            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
+        endif()
+    elseif(COMPILER_SUPPORTS_CXX0X)
+        message(STATUS "C++0x is supported.")
+        if(${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
+            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++0x -stdlib=libc++")
+        else()
+            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++0x")
+        endif()
+    else()
+        message(STATUS "The compiler ${CMAKE_CXX_COMPILER} has no C++11 support. Please use a different C++ compiler.")
+    endif()
+endif()
+
+set(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin)
+set(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR}/lib)
+
+set(CPR_LIBRARIES cpr CACHE INTERNAL "")
+set(CPR_INCLUDE_DIRS ${CMAKE_CURRENT_SOURCE_DIR}/include CACHE INTERNAL "")
+
+macro(cpr_option OPTION_NAME OPTION_TEXT OPTION_DEFAULT)
+    option(${OPTION_NAME} ${OPTION_TEXT} ${OPTION_DEFAULT})
+    if(DEFINED ENV{${OPTION_NAME}})
+        # Allow setting the option through an environment variable
+        set(${OPTION_NAME} $ENV{${OPTION_NAME}})
+    endif()
+    if(${OPTION_NAME})
+        add_definitions(-D${OPTION_NAME})
+    endif()
+    message(STATUS "  ${OPTION_NAME}: ${${OPTION_NAME}}")
+endmacro()
+
+message(STATUS "C++ Requests CMake Options")
+message(STATUS "=======================================================")
+cpr_option(USE_SYSTEM_CURL
+	"If ON, this project will look in the system paths for an installed curl library" ON)
+cpr_option(BUILD_CPR_TESTS "Set to ON to build cpr tests." OFF)
+cpr_option(GENERATE_COVERAGE "Set to ON to generate coverage reports." OFF)
+cpr_option(CPR_CURL_NOSIGNAL "Set to ON to disable use of signals in libcurl." OFF)
+cpr_option(USE_SYSTEM_GTEST
+	"If ON, this project will look in the system paths for an installed gtest library" ON)
+cpr_option(CMAKE_USE_OPENSSL "Use OpenSSL code. Experimental" ON)
+message(STATUS "=======================================================")
+
+if(BUILD_CPR_TESTS)
+    enable_testing()
+endif()
+
+add_subdirectory(opt)
+add_subdirectory(cpr)
+if(BUILD_CPR_TESTS)
+    add_subdirectory(test)
+endif()
diff --git a/cpr/CONTRIBUTING.md b/cpr/CONTRIBUTING.md
new file mode 100644
index 0000000..abfb97c
--- /dev/null
+++ b/cpr/CONTRIBUTING.md
@@ -0,0 +1,27 @@
+# Contributing to C++ Requests
+
+Please fork this repository and contribute back using [pull requests](https://github.com/whoshuu/cpr/pulls). Features can be requested using [issues](https://github.com/whoshuu/cpr/issues). All code, comments, and critiques are greatly appreciated.
+
+## Formatting
+
+To avoid unproductive debates on formatting, this project uses `clang-format` to ensure a consistent style across all source files. Currently, `clang-format` 3.8 is the version of `clang-format` we use. The format file can be found [here](https://github.com/whoshuu/cpr/blob/master/.clang-format). To install `clang-format` on Ubuntu, run this:
+
+```
+apt-get install clang-format-3.8
+```
+
+To install `clang-format` on OS X, run this:
+
+```
+brew install clang-format
+```
+
+Note that `brew` might install a later version of `clang-format`, but it should be mostly compatible with what's run on the Travis servers.
+
+To run `clang-format` on every source file, run this in the root directory:
+
+```
+./format-check.sh
+```
+
+This should indicate which files need formatting and also show a diff of the requested changes. More specific usage instructions can be found on the official [LLVM website](http://releases.llvm.org/3.8.0/tools/clang/docs/ClangFormat.html).
diff --git a/cpr/LICENSE b/cpr/LICENSE
new file mode 100644
index 0000000..d173854
--- /dev/null
+++ b/cpr/LICENSE
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright (c) 2017 Huu Nguyen
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/cpr/README.md b/cpr/README.md
new file mode 100644
index 0000000..ccaee78
--- /dev/null
+++ b/cpr/README.md
@@ -0,0 +1,96 @@
+# C++ Requests: Curl for People <img align="right" height="40" src="http://i.imgur.com/d9Xtyts.png">
+
+[![Build Status](https://travis-ci.org/whoshuu/cpr.svg?branch=master)](https://travis-ci.org/whoshuu/cpr) [![Build status](https://ci.appveyor.com/api/projects/status/imalkp3a6hblpj5y/branch/master?svg=true)](https://ci.appveyor.com/project/whoshuu/cpr/branch/master) [![Coverage Status](https://coveralls.io/repos/whoshuu/cpr/badge.svg?branch=master&service=github)](https://coveralls.io/github/whoshuu/cpr) [![Documentation](https://img.shields.io/badge/documentation-master-brightgreen.svg)](https://whoshuu.github.io/cpr/)
+
+C++ Requests is a simple wrapper around [libcurl](http://curl.haxx.se/libcurl) inspired by the excellent [Python Requests](https://github.com/kennethreitz/requests) project.
+
+Despite its name, libcurl's easy interface is anything but, and making mistakes misusing it is a common source of error and frustration. Using the more expressive language facilities of C++11, this library captures the essence of making network calls into a few concise idioms.
+
+Here's a quick GET request:
+
+```c++
+#include <cpr/cpr.h>
+
+int main(int argc, char** argv) {
+    auto r = cpr::Get(cpr::Url{"https://api.github.com/repos/whoshuu/cpr/contributors"},
+                      cpr::Authentication{"user", "pass"},
+                      cpr::Parameters{{"anon", "true"}, {"key", "value"}});
+    r.status_code;                  // 200
+    r.header["content-type"];       // application/json; charset=utf-8
+    r.text;                         // JSON text string
+}
+```
+
+And here's [less functional, more complicated code, without cpr](https://gist.github.com/whoshuu/2dc858b8730079602044).
+
+## Documentation
+
+You can find the latest documentation [here](https://whoshuu.github.io/cpr). It's a work in progress, but it should give you a better idea of how to use the library than the [tests](https://github.com/whoshuu/cpr/tree/master/test) currently do.
+
+## Features
+
+C++ Requests currently supports:
+
+* Custom headers
+* Url encoded parameters
+* Url encoded POST values
+* Multipart form POST upload
+* File POST upload
+* Basic authentication
+* Digest authentication
+* Timeout specification
+* Timeout for low speed connection
+* Asynchronous requests
+* :cookie: support!
+* Proxy support
+* Callback interface
+* PUT methods
+* DELETE methods
+* HEAD methods
+* OPTIONS methods
+* PATCH methods
+
+## Planned
+
+Support for the following will be forthcoming (in rough order of implementation priority):
+
+* [Streamed requests](https://github.com/whoshuu/cpr/issues/25)
+* [OpenSSL support](https://github.com/whoshuu/cpr/issues/31)
+
+and much more!
+
+## Usage
+
+For just getting this library up and running, I highly recommend forking the [example project](https://github.com/whoshuu/cpr-example). It's configured with the minimum CMake magic and boilerplate needed to start playing around with networked applications.
+
+If you already have a project you need to integrate C++ Requests with, the primary way is to use git submodules. Add this repository as a submodule of your root repository:
+
+```shell
+git submodule add git@github.com:whoshuu/cpr.git
+OR
+git submodule add https://github.com/whoshuu/cpr.git
+
+git submodule update --init --recursive
+```
+
+Next, add this subdirectory to your CMakeLists.txt before declaring any targets that might use it:
+
+```cmake
+add_subdirectory(cpr)
+```
+
+This will produce two important CMake variables, `CPR_INCLUDE_DIRS` and `CPR_LIBRARIES`, which you'll use in the typical way:
+
+```cmake
+include_directories(${CPR_INCLUDE_DIRS})
+target_link_libraries(your_target_name ${CPR_LIBRARIES})
+```
+
+and that should do it! Using the submodule method of integrating C++ Requests, there's no need to handle libcurl yourself, all of those dependencies are taken care of for you.
+
+## Requirements
+
+The only explicit requirements are:
+
+* a C++11 compatible compiler such as Clang or GCC. The minimum required version of GCC is unknown, so if anyone has trouble building this library with a specific version of GCC, do let me know
+* curl and its development libraries
diff --git a/cpr/VERSION b/cpr/VERSION
new file mode 100644
index 0000000..f0bb29e
--- /dev/null
+++ b/cpr/VERSION
@@ -0,0 +1 @@
+1.3.0
diff --git a/cpr/appveyor.yml b/cpr/appveyor.yml
new file mode 100644
index 0000000..2f88ceb
--- /dev/null
+++ b/cpr/appveyor.yml
@@ -0,0 +1,16 @@
+version: '1.1.{build}'
+configuration:
+    - RELEASE
+    - DEBUG
+os: Visual Studio 2015
+before_build:
+    - git submodule update --init --recursive
+    - set CMAKE_USE_OPENSSL=OFF
+    - mkdir build
+    - cd build
+    - cmake -DCMAKE_BUILD_TYPE=%Configuration% .. -G "Visual Studio 14 2015"
+build:
+    project: C:\projects\cpr\build\cpr.sln
+test_script:
+    - cd C:\projects\cpr\build
+    - ctest -VV -C %Configuration%
diff --git a/cpr/cpr-config.cmake b/cpr/cpr-config.cmake
new file mode 100644
index 0000000..58ab483
--- /dev/null
+++ b/cpr/cpr-config.cmake
@@ -0,0 +1,26 @@
+# - C++ Requests, Curl for People
+# This module is a libcurl wrapper written in modern C++.
+# It provides an easy, intuitive, and efficient interface to
+# a host of networking methods.
+#
+# Finding this module will define the following variables:
+#  CPR_FOUND - True if the core library has been found
+#  CPR_LIBRARIES - Path to the core library archive
+#  CPR_INCLUDE_DIRS - Path to the include directories. Gives access
+#                     to cpr.h, which must be included in every
+#                     file that uses this interface
+
+find_path(CPR_INCLUDE_DIR
+          NAMES cpr.h)
+
+find_library(CPR_LIBRARY
+             NAMES cpr
+             HINTS ${CPR_LIBRARY_ROOT})
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(CPR REQUIRED_VARS CPR_LIBRARY CPR_INCLUDE_DIR)
+
+if(CPR_FOUND)
+    set(CPR_LIBRARIES ${CPR_LIBRARY})
+    set(CPR_INCLUDE_DIRS ${CPR_INCLUDE_DIR})
+endif()
diff --git a/cpr/cpr/CMakeLists.txt b/cpr/cpr/CMakeLists.txt
new file mode 100644
index 0000000..39c6c12
--- /dev/null
+++ b/cpr/cpr/CMakeLists.txt
@@ -0,0 +1,55 @@
+message(STATUS "Using CURL_INCLUDE_DIRS: ${CURL_INCLUDE_DIRS}.")
+
+add_library(${CPR_LIBRARIES}
+
+    # Source files
+    auth.cpp
+    cookies.cpp
+    cprtypes.cpp
+    digest.cpp
+    error.cpp
+    multipart.cpp
+    parameters.cpp
+    payload.cpp
+    proxies.cpp
+    session.cpp
+    timeout.cpp
+    util.cpp
+    ssl_options.cpp
+
+    # Header files (useful in IDEs)
+    "${CPR_INCLUDE_DIRS}/cpr/api.h"
+    "${CPR_INCLUDE_DIRS}/cpr/auth.h"
+    "${CPR_INCLUDE_DIRS}/cpr/body.h"
+    "${CPR_INCLUDE_DIRS}/cpr/cookies.h"
+    "${CPR_INCLUDE_DIRS}/cpr/cpr.h"
+    "${CPR_INCLUDE_DIRS}/cpr/cprtypes.h"
+    "${CPR_INCLUDE_DIRS}/cpr/curlholder.h"
+    "${CPR_INCLUDE_DIRS}/cpr/defines.h"
+    "${CPR_INCLUDE_DIRS}/cpr/digest.h"
+    "${CPR_INCLUDE_DIRS}/cpr/error.h"
+    "${CPR_INCLUDE_DIRS}/cpr/max_redirects.h"
+    "${CPR_INCLUDE_DIRS}/cpr/multipart.h"
+    "${CPR_INCLUDE_DIRS}/cpr/parameters.h"
+    "${CPR_INCLUDE_DIRS}/cpr/payload.h"
+    "${CPR_INCLUDE_DIRS}/cpr/proxies.h"
+    "${CPR_INCLUDE_DIRS}/cpr/response.h"
+    "${CPR_INCLUDE_DIRS}/cpr/session.h"
+    "${CPR_INCLUDE_DIRS}/cpr/timeout.h"
+    "${CPR_INCLUDE_DIRS}/cpr/util.h"
+    "${CPR_INCLUDE_DIRS}/cpr/ssl_options.h")
+
+message(STATUS "Using CURL_LIBRARIES: ${CURL_LIBRARIES}.")
+target_link_libraries(${CPR_LIBRARIES}
+    ${CURL_LIBRARIES})
+
+if(NOT (CMAKE_VERSION VERSION_LESS 3.0))
+    target_include_directories(${CPR_LIBRARIES}
+        PUBLIC
+        ${CPR_INCLUDE_DIRS}
+        ${CURL_INCLUDE_DIRS})
+else()
+    include_directories(
+        ${CPR_INCLUDE_DIRS}
+        ${CURL_INCLUDE_DIRS})
+endif()
diff --git a/cpr/cpr/auth.cpp b/cpr/cpr/auth.cpp
new file mode 100644
index 0000000..ff7c3a9
--- /dev/null
+++ b/cpr/cpr/auth.cpp
@@ -0,0 +1,9 @@
+#include "cpr/auth.h"
+
+namespace cpr {
+
+const char* Authentication::GetAuthString() const noexcept {
+    return auth_string_.data();
+}
+
+} // namespace cpr
diff --git a/cpr/cpr/cookies.cpp b/cpr/cpr/cookies.cpp
new file mode 100644
index 0000000..21decd3
--- /dev/null
+++ b/cpr/cpr/cookies.cpp
@@ -0,0 +1,30 @@
+#include "cpr/cookies.h"
+
+#include "cpr/util.h"
+
+namespace cpr {
+
+Cookies::Cookies(const std::initializer_list<std::pair<const std::string, std::string>>& pairs)
+        : map_{pairs} {}
+
+std::string Cookies::GetEncoded() const {
+    std::stringstream stream;
+    for (const auto& item : map_) {
+        stream << cpr::util::urlEncode(item.first) << "=";
+        // special case version 1 cookies, which can be distinguished by
+        // beginning and trailing quotes
+        if (!item.second.empty() && item.second.front() == '"' && item.second.back() == '"') {
+            stream << item.second;
+        } else {
+            stream << cpr::util::urlEncode(item.second);
+        }
+        stream << "; ";
+    }
+    return stream.str();
+}
+
+std::string& Cookies::operator[](const std::string& key) {
+    return map_[key];
+}
+
+} // namespace cpr
diff --git a/cpr/cpr/cprtypes.cpp b/cpr/cpr/cprtypes.cpp
new file mode 100644
index 0000000..4daf6de
--- /dev/null
+++ b/cpr/cpr/cprtypes.cpp
@@ -0,0 +1,14 @@
+#include "cpr/cprtypes.h"
+
+#include <algorithm>
+#include <cctype>
+
+namespace cpr {
+
+bool CaseInsensitiveCompare::operator()(const std::string& a, const std::string& b) const noexcept {
+    return std::lexicographical_compare(
+            a.begin(), a.end(), b.begin(), b.end(),
+            [](unsigned char ac, unsigned char bc) { return std::tolower(ac) < std::tolower(bc); });
+}
+
+} // namespace cpr
diff --git a/cpr/cpr/digest.cpp b/cpr/cpr/digest.cpp
new file mode 100644
index 0000000..252c5d2
--- /dev/null
+++ b/cpr/cpr/digest.cpp
@@ -0,0 +1,9 @@
+#include "cpr/digest.h"
+
+namespace cpr {
+
+const char* Digest::GetAuthString() const noexcept {
+    return Authentication::GetAuthString();
+}
+
+} // namespace cpr
diff --git a/cpr/cpr/error.cpp b/cpr/cpr/error.cpp
new file mode 100644
index 0000000..713cb10
--- /dev/null
+++ b/cpr/cpr/error.cpp
@@ -0,0 +1,62 @@
+#include "cpr/error.h"
+
+#include <curl/curl.h>
+
+namespace cpr {
+
+ErrorCode Error::getErrorCodeForCurlError(std::int32_t curl_code) {
+    switch (curl_code) {
+        case CURLE_OK:
+            return ErrorCode::OK;
+        case CURLE_UNSUPPORTED_PROTOCOL:
+            return ErrorCode::UNSUPPORTED_PROTOCOL;
+        case CURLE_URL_MALFORMAT:
+            return ErrorCode::INVALID_URL_FORMAT;
+        case CURLE_COULDNT_RESOLVE_PROXY:
+            return ErrorCode::PROXY_RESOLUTION_FAILURE;
+        case CURLE_COULDNT_RESOLVE_HOST:
+            return ErrorCode::HOST_RESOLUTION_FAILURE;
+        case CURLE_COULDNT_CONNECT:
+            return ErrorCode::CONNECTION_FAILURE;
+        case CURLE_OPERATION_TIMEDOUT:
+            return ErrorCode::OPERATION_TIMEDOUT;
+        case CURLE_SSL_CONNECT_ERROR:
+            return ErrorCode::SSL_CONNECT_ERROR;
+        case CURLE_PEER_FAILED_VERIFICATION:
+            return ErrorCode::SSL_REMOTE_CERTIFICATE_ERROR;
+        case CURLE_GOT_NOTHING:
+            return ErrorCode::EMPTY_RESPONSE;
+        case CURLE_SSL_ENGINE_NOTFOUND:
+            return ErrorCode::GENERIC_SSL_ERROR;
+        case CURLE_SSL_ENGINE_SETFAILED:
+            return ErrorCode::GENERIC_SSL_ERROR;
+        case CURLE_SEND_ERROR:
+            return ErrorCode::NETWORK_SEND_FAILURE;
+        case CURLE_RECV_ERROR:
+            return ErrorCode::NETWORK_RECEIVE_ERROR;
+        case CURLE_SSL_CERTPROBLEM:
+            return ErrorCode::SSL_LOCAL_CERTIFICATE_ERROR;
+        case CURLE_SSL_CIPHER:
+            return ErrorCode::GENERIC_SSL_ERROR;
+        case CURLE_SSL_CACERT:
+            return ErrorCode::SSL_CACERT_ERROR;
+        case CURLE_USE_SSL_FAILED:
+            return ErrorCode::GENERIC_SSL_ERROR;
+        case CURLE_SSL_ENGINE_INITFAILED:
+            return ErrorCode::GENERIC_SSL_ERROR;
+        case CURLE_SSL_CACERT_BADFILE:
+            return ErrorCode::SSL_CACERT_ERROR;
+        case CURLE_SSL_SHUTDOWN_FAILED:
+            return ErrorCode::GENERIC_SSL_ERROR;
+        case CURLE_SSL_CRL_BADFILE:
+            return ErrorCode::SSL_CACERT_ERROR;
+        case CURLE_SSL_ISSUER_ERROR:
+            return ErrorCode::SSL_CACERT_ERROR;
+        case CURLE_TOO_MANY_REDIRECTS:
+            return ErrorCode::OK;
+        default:
+            return ErrorCode::INTERNAL_ERROR;
+    }
+}
+
+} // namespace cpr
diff --git a/cpr/cpr/multipart.cpp b/cpr/cpr/multipart.cpp
new file mode 100644
index 0000000..c2e030a
--- /dev/null
+++ b/cpr/cpr/multipart.cpp
@@ -0,0 +1,7 @@
+#include "cpr/multipart.h"
+
+namespace cpr {
+
+Multipart::Multipart(const std::initializer_list<Part>& parts) : parts{parts} {}
+
+} // namespace cpr
diff --git a/cpr/cpr/parameters.cpp b/cpr/cpr/parameters.cpp
new file mode 100644
index 0000000..1adb510
--- /dev/null
+++ b/cpr/cpr/parameters.cpp
@@ -0,0 +1,30 @@
+#include "cpr/parameters.h"
+
+#include <initializer_list>
+#include <string>
+
+#include "cpr/util.h"
+
+namespace cpr {
+
+Parameters::Parameters(const std::initializer_list<Parameter>& parameters) {
+    for (const auto& parameter : parameters) {
+        AddParameter(parameter);
+    }
+}
+
+void Parameters::AddParameter(const Parameter& parameter) {
+    if (!content.empty()) {
+        content += "&";
+    }
+
+    auto escapedKey = cpr::util::urlEncode(parameter.key);
+    if (parameter.value.empty()) {
+        content += escapedKey;
+    } else {
+        auto escapedValue = cpr::util::urlEncode(parameter.value);
+        content += escapedKey + "=" + escapedValue;
+    }
+}
+
+} // namespace cpr
diff --git a/cpr/cpr/payload.cpp b/cpr/cpr/payload.cpp
new file mode 100644
index 0000000..de7e8cc
--- /dev/null
+++ b/cpr/cpr/payload.cpp
@@ -0,0 +1,20 @@
+#include "cpr/payload.h"
+
+#include <initializer_list>
+#include <string>
+
+#include "cpr/util.h"
+
+namespace cpr {
+
+Payload::Payload(const std::initializer_list<Pair>& pairs) : Payload(begin(pairs), end(pairs)) {}
+
+void Payload::AddPair(const Pair& pair) {
+    if (!content.empty()) {
+        content += "&";
+    }
+    auto escaped = cpr::util::urlEncode(pair.value);
+    content += pair.key + "=" + escaped;
+}
+
+} // namespace cpr
diff --git a/cpr/cpr/proxies.cpp b/cpr/cpr/proxies.cpp
new file mode 100644
index 0000000..446f7d7
--- /dev/null
+++ b/cpr/cpr/proxies.cpp
@@ -0,0 +1,21 @@
+#include "cpr/proxies.h"
+
+#include <initializer_list>
+#include <map>
+#include <string>
+#include <utility>
+
+namespace cpr {
+
+Proxies::Proxies(const std::initializer_list<std::pair<const std::string, std::string>>& hosts)
+        : hosts_{hosts} {}
+
+bool Proxies::has(const std::string& protocol) const {
+    return hosts_.count(protocol) > 0;
+}
+
+const std::string& Proxies::operator[](const std::string& protocol) {
+    return hosts_[protocol];
+}
+
+} // namespace cpr
diff --git a/cpr/cpr/session.cpp b/cpr/cpr/session.cpp
new file mode 100644
index 0000000..371a1e2
--- /dev/null
+++ b/cpr/cpr/session.cpp
@@ -0,0 +1,477 @@
+#include "cpr/session.h"
+
+#include <algorithm>
+#include <functional>
+#include <string>
+
+#include <curl/curl.h>
+
+#include "cpr/curlholder.h"
+#include "cpr/util.h"
+
+namespace cpr {
+
+class Session::Impl {
+  public:
+    Impl();
+
+    void SetUrl(const Url& url);
+    void SetParameters(const Parameters& parameters);
+    void SetParameters(Parameters&& parameters);
+    void SetHeader(const Header& header);
+    void SetTimeout(const Timeout& timeout);
+    void SetAuth(const Authentication& auth);
+    void SetDigest(const Digest& auth);
+    void SetPayload(Payload&& payload);
+    void SetPayload(const Payload& payload);
+    void SetProxies(Proxies&& proxies);
+    void SetProxies(const Proxies& proxies);
+    void SetMultipart(Multipart&& multipart);
+    void SetMultipart(const Multipart& multipart);
+    void SetRedirect(const bool& redirect);
+    void SetMaxRedirects(const MaxRedirects& max_redirects);
+    void SetCookies(const Cookies& cookies);
+    void SetBody(Body&& body);
+    void SetBody(const Body& body);
+    void SetLowSpeed(const LowSpeed& low_speed);
+    void SetVerifySsl(const VerifySsl& verify);
+
+    Response Delete();
+    Response Get();
+    Response Head();
+    Response Options();
+    Response Patch();
+    Response Post();
+    Response Put();
+
+  private:
+    std::unique_ptr<CurlHolder, std::function<void(CurlHolder*)>> curl_;
+    Url url_;
+    Parameters parameters_;
+    Proxies proxies_;
+
+    Response makeRequest(CURL* curl);
+    static void freeHolder(CurlHolder* holder);
+    static CurlHolder* newHolder();
+};
+
+Session::Impl::Impl() {
+    curl_ = std::unique_ptr<CurlHolder, std::function<void(CurlHolder*)>>(newHolder(),
+                                                                          &Impl::freeHolder);
+    auto curl = curl_->handle;
+    if (curl) {
+        // Set up some sensible defaults
+        auto version_info = curl_version_info(CURLVERSION_NOW);
+        auto version = std::string{"curl/"} + std::string{version_info->version};
+        curl_easy_setopt(curl, CURLOPT_USERAGENT, version.data());
+        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
+        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
+        curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 50L);
+        curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, curl_->error);
+        curl_easy_setopt(curl, CURLOPT_COOKIEFILE, "");
+#ifdef CPR_CURL_NOSIGNAL
+        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);
+#endif
+#if LIBCURL_VERSION_MAJOR >= 7
+#if LIBCURL_VERSION_MINOR >= 25
+#if LIBCURL_VERSION_PATCH >= 0
+        curl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, 1L);
+#endif
+#endif
+#endif
+    }
+}
+
+void Session::Impl::freeHolder(CurlHolder* holder) {
+    curl_easy_cleanup(holder->handle);
+    curl_slist_free_all(holder->chunk);
+    curl_formfree(holder->formpost);
+    delete holder;
+}
+
+CurlHolder* Session::Impl::newHolder() {
+    CurlHolder* holder = new CurlHolder();
+    holder->handle = curl_easy_init();
+    holder->chunk = NULL;
+    holder->formpost = NULL;
+    return holder;
+}
+
+void Session::Impl::SetUrl(const Url& url) {
+    url_ = url;
+}
+
+void Session::Impl::SetParameters(const Parameters& parameters) {
+    parameters_ = parameters;
+}
+
+void Session::Impl::SetParameters(Parameters&& parameters) {
+    parameters_ = std::move(parameters);
+}
+
+void Session::Impl::SetHeader(const Header& header) {
+    auto curl = curl_->handle;
+    if (curl) {
+        struct curl_slist* chunk = NULL;
+        for (auto item = header.cbegin(); item != header.cend(); ++item) {
+            auto header_string = std::string{item->first};
+            if (item->second.empty()) {
+                header_string += ";";
+            } else {
+                header_string += ": " + item->second;
+            }
+
+            auto temp = curl_slist_append(chunk, header_string.data());
+            if (temp) {
+                chunk = temp;
+            }
+        }
+        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, chunk);
+
+        curl_slist_free_all(curl_->chunk);
+        curl_->chunk = chunk;
+    }
+}
+
+void Session::Impl::SetTimeout(const Timeout& timeout) {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, timeout.Milliseconds());
+    }
+}
+
+void Session::Impl::SetAuth(const Authentication& auth) {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);
+        curl_easy_setopt(curl, CURLOPT_USERPWD, auth.GetAuthString());
+    }
+}
+
+void Session::Impl::SetDigest(const Digest& auth) {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_DIGEST);
+        curl_easy_setopt(curl, CURLOPT_USERPWD, auth.GetAuthString());
+    }
+}
+
+void Session::Impl::SetPayload(Payload&& payload) {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, payload.content.length());
+        curl_easy_setopt(curl, CURLOPT_COPYPOSTFIELDS, payload.content.data());
+    }
+}
+
+void Session::Impl::SetPayload(const Payload& payload) {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, payload.content.length());
+        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, payload.content.data());
+    }
+}
+
+void Session::Impl::SetProxies(const Proxies& proxies) {
+    proxies_ = proxies;
+}
+
+void Session::Impl::SetProxies(Proxies&& proxies) {
+    proxies_ = std::move(proxies);
+}
+
+void Session::Impl::SetMultipart(Multipart&& multipart) {
+    auto curl = curl_->handle;
+    if (curl) {
+        struct curl_httppost* formpost = NULL;
+        struct curl_httppost* lastptr = NULL;
+
+        for (auto& part : multipart.parts) {
+            std::vector<struct curl_forms> formdata;
+            formdata.push_back({CURLFORM_COPYNAME, part.name.data()});
+            if (part.is_buffer) {
+                formdata.push_back({CURLFORM_BUFFER, part.value.data()});
+                formdata.push_back(
+                        {CURLFORM_COPYCONTENTS, reinterpret_cast<const char*>(part.data)});
+                formdata.push_back(
+                        {CURLFORM_CONTENTSLENGTH, reinterpret_cast<const char*>(part.datalen)});
+            } else if (part.is_file) {
+                formdata.push_back({CURLFORM_FILE, part.value.data()});
+            } else {
+                formdata.push_back({CURLFORM_COPYCONTENTS, part.value.data()});
+            }
+            if (!part.content_type.empty()) {
+                formdata.push_back({CURLFORM_CONTENTTYPE, part.content_type.data()});
+            }
+            formdata.push_back({CURLFORM_END, nullptr});
+            curl_formadd(&formpost, &lastptr, CURLFORM_ARRAY, formdata.data(), CURLFORM_END);
+        }
+        curl_easy_setopt(curl, CURLOPT_HTTPPOST, formpost);
+
+        curl_formfree(curl_->formpost);
+        curl_->formpost = formpost;
+    }
+}
+
+void Session::Impl::SetMultipart(const Multipart& multipart) {
+    auto curl = curl_->handle;
+    if (curl) {
+        struct curl_httppost* formpost = NULL;
+        struct curl_httppost* lastptr = NULL;
+
+        for (auto& part : multipart.parts) {
+            std::vector<struct curl_forms> formdata;
+            formdata.push_back({CURLFORM_PTRNAME, part.name.data()});
+            if (part.is_buffer) {
+                formdata.push_back({CURLFORM_BUFFER, part.value.data()});
+                formdata.push_back({CURLFORM_BUFFERPTR, reinterpret_cast<const char*>(part.data)});
+                formdata.push_back(
+                        {CURLFORM_BUFFERLENGTH, reinterpret_cast<const char*>(part.datalen)});
+            } else if (part.is_file) {
+                formdata.push_back({CURLFORM_FILE, part.value.data()});
+            } else {
+                formdata.push_back({CURLFORM_PTRCONTENTS, part.value.data()});
+            }
+            if (!part.content_type.empty()) {
+                formdata.push_back({CURLFORM_CONTENTTYPE, part.content_type.data()});
+            }
+            formdata.push_back({CURLFORM_END, nullptr});
+            curl_formadd(&formpost, &lastptr, CURLFORM_ARRAY, formdata.data(), CURLFORM_END);
+        }
+        curl_easy_setopt(curl, CURLOPT_HTTPPOST, formpost);
+
+        curl_formfree(curl_->formpost);
+        curl_->formpost = formpost;
+    }
+}
+
+void Session::Impl::SetRedirect(const bool& redirect) {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, std::int32_t(redirect));
+    }
+}
+
+void Session::Impl::SetMaxRedirects(const MaxRedirects& max_redirects) {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_MAXREDIRS, max_redirects.number_of_redirects);
+    }
+}
+
+void Session::Impl::SetCookies(const Cookies& cookies) {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_COOKIELIST, "ALL");
+        curl_easy_setopt(curl, CURLOPT_COOKIE, cookies.GetEncoded().data());
+    }
+}
+
+void Session::Impl::SetBody(Body&& body) {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, body.length());
+        curl_easy_setopt(curl, CURLOPT_COPYPOSTFIELDS, body.data());
+    }
+}
+
+void Session::Impl::SetBody(const Body& body) {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, body.length());
+        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.data());
+    }
+}
+
+void Session::Impl::SetLowSpeed(const LowSpeed& low_speed) {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, low_speed.limit);
+        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, low_speed.time);
+    }
+}
+
+void Session::Impl::SetVerifySsl(const VerifySsl& verify) {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, verify ? 1L : 0L);
+        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, verify ? 2L : 0L);
+    }
+}
+
+Response Session::Impl::Delete() {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_HTTPGET, 0L);
+        curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
+        curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "DELETE");
+    }
+
+    return makeRequest(curl);
+}
+
+Response Session::Impl::Get() {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
+        curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "GET");
+    }
+
+    return makeRequest(curl);
+}
+
+Response Session::Impl::Head() {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, NULL);
+        curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
+    }
+
+    return makeRequest(curl);
+}
+
+Response Session::Impl::Options() {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
+        curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "OPTIONS");
+    }
+
+    return makeRequest(curl);
+}
+
+Response Session::Impl::Patch() {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
+        curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PATCH");
+    }
+
+    return makeRequest(curl);
+}
+
+Response Session::Impl::Post() {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
+        curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "POST");
+    }
+
+    return makeRequest(curl);
+}
+
+Response Session::Impl::Put() {
+    auto curl = curl_->handle;
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
+        curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PUT");
+    }
+
+    return makeRequest(curl);
+}
+
+Response Session::Impl::makeRequest(CURL* curl) {
+    if (!parameters_.content.empty()) {
+        Url new_url{url_ + "?" + parameters_.content};
+        curl_easy_setopt(curl, CURLOPT_URL, new_url.data());
+    } else {
+        curl_easy_setopt(curl, CURLOPT_URL, url_.data());
+    }
+
+    auto protocol = url_.substr(0, url_.find(':'));
+    if (proxies_.has(protocol)) {
+        curl_easy_setopt(curl, CURLOPT_PROXY, proxies_[protocol].data());
+    } else {
+        curl_easy_setopt(curl, CURLOPT_PROXY, "");
+    }
+
+    curl_->error[0] = '\0';
+
+    std::string response_string;
+    std::string header_string;
+    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, cpr::util::writeFunction);
+    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_string);
+    curl_easy_setopt(curl, CURLOPT_HEADERDATA, &header_string);
+
+    auto curl_error = curl_easy_perform(curl);
+
+    char* raw_url;
+    long response_code;
+    double elapsed;
+    curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);
+    curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &elapsed);
+    curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &raw_url);
+
+    Cookies cookies;
+    struct curl_slist* raw_cookies;
+    curl_easy_getinfo(curl, CURLINFO_COOKIELIST, &raw_cookies);
+    for (struct curl_slist* nc = raw_cookies; nc; nc = nc->next) {
+        auto tokens = cpr::util::split(nc->data, '\t');
+        auto value = tokens.back();
+        tokens.pop_back();
+        cookies[tokens.back()] = value;
+    }
+    curl_slist_free_all(raw_cookies);
+
+    return Response{static_cast<std::int32_t>(response_code),
+                    std::move(response_string),
+                    cpr::util::parseHeader(header_string),
+                    std::move(raw_url),
+                    elapsed,
+                    std::move(cookies),
+                    Error(curl_error, curl_->error)};
+}
+
+// clang-format off
+Session::Session() : pimpl_{ new Impl{} } {}
+Session::~Session() {}
+void Session::SetUrl(const Url& url) { pimpl_->SetUrl(url); }
+void Session::SetParameters(const Parameters& parameters) { pimpl_->SetParameters(parameters); }
+void Session::SetParameters(Parameters&& parameters) { pimpl_->SetParameters(std::move(parameters)); }
+void Session::SetHeader(const Header& header) { pimpl_->SetHeader(header); }
+void Session::SetTimeout(const Timeout& timeout) { pimpl_->SetTimeout(timeout); }
+void Session::SetAuth(const Authentication& auth) { pimpl_->SetAuth(auth); }
+void Session::SetDigest(const Digest& auth) { pimpl_->SetDigest(auth); }
+void Session::SetPayload(const Payload& payload) { pimpl_->SetPayload(payload); }
+void Session::SetPayload(Payload&& payload) { pimpl_->SetPayload(std::move(payload)); }
+void Session::SetProxies(const Proxies& proxies) { pimpl_->SetProxies(proxies); }
+void Session::SetProxies(Proxies&& proxies) { pimpl_->SetProxies(std::move(proxies)); }
+void Session::SetMultipart(const Multipart& multipart) { pimpl_->SetMultipart(multipart); }
+void Session::SetMultipart(Multipart&& multipart) { pimpl_->SetMultipart(std::move(multipart)); }
+void Session::SetRedirect(const bool& redirect) { pimpl_->SetRedirect(redirect); }
+void Session::SetMaxRedirects(const MaxRedirects& max_redirects) { pimpl_->SetMaxRedirects(max_redirects); }
+void Session::SetCookies(const Cookies& cookies) { pimpl_->SetCookies(cookies); }
+void Session::SetBody(const Body& body) { pimpl_->SetBody(body); }
+void Session::SetBody(Body&& body) { pimpl_->SetBody(std::move(body)); }
+void Session::SetLowSpeed(const LowSpeed& low_speed) { pimpl_->SetLowSpeed(low_speed); }
+void Session::SetVerifySsl(const VerifySsl& verify) { pimpl_->SetVerifySsl(verify); }
+void Session::SetOption(const Url& url) { pimpl_->SetUrl(url); }
+void Session::SetOption(const Parameters& parameters) { pimpl_->SetParameters(parameters); }
+void Session::SetOption(Parameters&& parameters) { pimpl_->SetParameters(std::move(parameters)); }
+void Session::SetOption(const Header& header) { pimpl_->SetHeader(header); }
+void Session::SetOption(const Timeout& timeout) { pimpl_->SetTimeout(timeout); }
+void Session::SetOption(const Authentication& auth) { pimpl_->SetAuth(auth); }
+void Session::SetOption(const Digest& auth) { pimpl_->SetDigest(auth); }
+void Session::SetOption(const Payload& payload) { pimpl_->SetPayload(payload); }
+void Session::SetOption(Payload&& payload) { pimpl_->SetPayload(std::move(payload)); }
+void Session::SetOption(const Proxies& proxies) { pimpl_->SetProxies(proxies); }
+void Session::SetOption(Proxies&& proxies) { pimpl_->SetProxies(std::move(proxies)); }
+void Session::SetOption(const Multipart& multipart) { pimpl_->SetMultipart(multipart); }
+void Session::SetOption(Multipart&& multipart) { pimpl_->SetMultipart(std::move(multipart)); }
+void Session::SetOption(const bool& redirect) { pimpl_->SetRedirect(redirect); }
+void Session::SetOption(const MaxRedirects& max_redirects) { pimpl_->SetMaxRedirects(max_redirects); }
+void Session::SetOption(const Cookies& cookies) { pimpl_->SetCookies(cookies); }
+void Session::SetOption(const Body& body) { pimpl_->SetBody(body); }
+void Session::SetOption(Body&& body) { pimpl_->SetBody(std::move(body)); }
+void Session::SetOption(const LowSpeed& low_speed) { pimpl_->SetLowSpeed(low_speed); }
+void Session::SetOption(const VerifySsl& verify) { pimpl_->SetVerifySsl(verify); }
+Response Session::Delete() { return pimpl_->Delete(); }
+Response Session::Get() { return pimpl_->Get(); }
+Response Session::Head() { return pimpl_->Head(); }
+Response Session::Options() { return pimpl_->Options(); }
+Response Session::Patch() { return pimpl_->Patch(); }
+Response Session::Post() { return pimpl_->Post(); }
+Response Session::Put() { return pimpl_->Put(); }
+// clang-format on
+
+} // namespace cpr
diff --git a/cpr/cpr/ssl_options.cpp b/cpr/cpr/ssl_options.cpp
new file mode 100644
index 0000000..79d77f7
--- /dev/null
+++ b/cpr/cpr/ssl_options.cpp
@@ -0,0 +1,11 @@
+#include "cpr/ssl_options.h"
+
+namespace cpr {
+
+VerifySsl::VerifySsl(bool verify) : verify_{verify} {}
+
+VerifySsl::operator bool() const {
+    return verify_;
+}
+
+} // namespace cpr
diff --git a/cpr/cpr/timeout.cpp b/cpr/cpr/timeout.cpp
new file mode 100644
index 0000000..259eb96
--- /dev/null
+++ b/cpr/cpr/timeout.cpp
@@ -0,0 +1,26 @@
+#include "cpr/timeout.h"
+
+#include <limits>
+#include <stdexcept>
+#include <string>
+#include <type_traits>
+
+namespace cpr {
+
+long Timeout::Milliseconds() const {
+    static_assert(std::is_same<std::chrono::milliseconds, decltype(ms)>::value,
+                  "Following casting expects milliseconds.");
+
+    if (ms.count() > std::numeric_limits<long>::max()) {
+        throw std::overflow_error("cpr::Timeout: timeout value overflow: " +
+                                  std::to_string(ms.count()) + " ms.");
+    }
+    if (ms.count() < std::numeric_limits<long>::min()) {
+        throw std::underflow_error("cpr::Timeout: timeout value underflow: " +
+                                   std::to_string(ms.count()) + " ms.");
+    }
+
+    return static_cast<long>(ms.count());
+}
+
+} // namespace cpr
diff --git a/cpr/cpr/util.cpp b/cpr/cpr/util.cpp
new file mode 100644
index 0000000..6832953
--- /dev/null
+++ b/cpr/cpr/util.cpp
@@ -0,0 +1,81 @@
+#include "cpr/util.h"
+
+#include <algorithm>
+#include <cctype>
+#include <cstdint>
+#include <iomanip>
+#include <sstream>
+#include <string>
+#include <vector>
+
+namespace cpr {
+namespace util {
+
+Header parseHeader(const std::string& headers) {
+    Header header;
+    std::vector<std::string> lines;
+    std::istringstream stream(headers);
+    {
+        std::string line;
+        while (std::getline(stream, line, '\n')) {
+            lines.push_back(line);
+        }
+    }
+
+    for (auto& line : lines) {
+        if (line.substr(0, 5) == "HTTP/") {
+            header.clear();
+        }
+
+        if (line.length() > 0) {
+            auto found = line.find(":");
+            if (found != std::string::npos) {
+                auto value = line.substr(found + 1);
+                value.erase(0, value.find_first_not_of("\t "));
+                value.resize(std::min(value.size(), value.find_last_not_of("\t\n\r ") + 1));
+                header[line.substr(0, found)] = value;
+            }
+        }
+    }
+
+    return header;
+}
+
+std::vector<std::string> split(const std::string& to_split, char delimiter) {
+    std::vector<std::string> tokens;
+
+    std::stringstream stream(to_split);
+    std::string item;
+    while (std::getline(stream, item, delimiter)) {
+        tokens.push_back(item);
+    }
+
+    return tokens;
+}
+
+size_t writeFunction(void* ptr, size_t size, size_t nmemb, std::string* data) {
+    data->append(static_cast<char*>(ptr), size * nmemb);
+    return size * nmemb;
+}
+
+std::string urlEncode(const std::string& value) {
+    std::ostringstream escaped;
+    escaped.fill('0');
+    escaped << std::hex;
+
+    for (auto i = value.cbegin(), n = value.cend(); i != n; ++i) {
+        std::string::value_type c = (*i);
+        // Keep alphanumeric and other accepted characters intact
+        if (std::isalnum(c) || c == '-' || c == '_' || c == '.' || c == '~') {
+            escaped << c;
+            continue;
+        }
+        // Any other characters are percent-encoded
+        escaped << '%' << std::setw(2) << std::int32_t(static_cast<unsigned char>(c));
+    }
+
+    return escaped.str();
+}
+
+} // namespace util
+} // namespace cpr
diff --git a/cpr/format-check.sh b/cpr/format-check.sh
new file mode 100755
index 0000000..45a6ca1
--- /dev/null
+++ b/cpr/format-check.sh
@@ -0,0 +1,37 @@
+#!/bin/bash
+
+
+which clang-format-3.8
+if [ $? -eq 0 ]
+then
+    format_command=clang-format-3.8
+else
+    format_command=clang-format
+fi
+
+format_error_exists=0
+
+for DIRECTORY in include cpr
+do
+    for FILE in $DIRECTORY/*.h $DIRECTORY/*.cpp
+    do
+        if [ -e $FILE ]
+        then
+            $format_command -style=file -output-replacements-xml $FILE | grep -c "<replacement " >/dev/null
+            if [ $? -ne 1 ]
+            then
+                echo "Please run clang-format on $FILE:"
+                $format_command -style=file $FILE | diff - $FILE
+                format_error_exists=1
+            fi
+        fi
+    done
+done
+
+if [ $format_error_exists -ne 0 ]
+then
+    echo "Some files require formatting"
+    exit 1
+fi
+
+exit 0
diff --git a/cpr/include/cpr/api.h b/cpr/include/cpr/api.h
new file mode 100644
index 0000000..43699d9
--- /dev/null
+++ b/cpr/include/cpr/api.h
@@ -0,0 +1,200 @@
+#ifndef CPR_API_H
+#define CPR_API_H
+
+#include <functional>
+#include <future>
+#include <string>
+
+#include "cpr/auth.h"
+#include "cpr/cprtypes.h"
+#include "cpr/defines.h"
+#include "cpr/digest.h"
+#include "cpr/multipart.h"
+#include "cpr/payload.h"
+#include "cpr/response.h"
+#include "cpr/session.h"
+
+namespace cpr {
+
+using AsyncResponse = std::future<Response>;
+
+namespace priv {
+
+template <typename T>
+void set_option(Session& session, T&& t) {
+    session.SetOption(CPR_FWD(t));
+}
+
+template <typename T, typename... Ts>
+void set_option(Session& session, T&& t, Ts&&... ts) {
+    set_option(session, CPR_FWD(t));
+    set_option(session, CPR_FWD(ts)...);
+}
+
+} // namespace priv
+
+// Get methods
+template <typename... Ts>
+Response Get(Ts&&... ts) {
+    Session session;
+    priv::set_option(session, CPR_FWD(ts)...);
+    return session.Get();
+}
+
+// Get async methods
+template <typename... Ts>
+AsyncResponse GetAsync(Ts... ts) {
+    return std::async(std::launch::async, [](Ts... ts) { return Get(std::move(ts)...); },
+                      std::move(ts)...);
+}
+
+// Get callback methods
+template <typename Then, typename... Ts>
+auto GetCallback(Then then, Ts... ts) -> std::future<decltype(then(Get(std::move(ts)...)))> {
+    return std::async(std::launch::async, [](Then then, Ts... ts) {
+        return then(Get(std::move(ts)...));
+    }, std::move(then), std::move(ts)...);
+}
+
+// Post methods
+template <typename... Ts>
+Response Post(Ts&&... ts) {
+    Session session;
+    priv::set_option(session, CPR_FWD(ts)...);
+    return session.Post();
+}
+
+// Post async methods
+template <typename... Ts>
+AsyncResponse PostAsync(Ts... ts) {
+    return std::async(std::launch::async, [](Ts... ts) { return Post(std::move(ts)...); },
+                      std::move(ts)...);
+}
+
+// Post callback methods
+template <typename Then, typename... Ts>
+auto PostCallback(Then then, Ts... ts) -> std::future<decltype(then(Post(std::move(ts)...)))> {
+    return std::async(std::launch::async, [](Then then, Ts... ts) {
+        return then(Post(std::move(ts)...));
+    }, std::move(then), std::move(ts)...);
+}
+
+// Put methods
+template <typename... Ts>
+Response Put(Ts&&... ts) {
+    Session session;
+    priv::set_option(session, CPR_FWD(ts)...);
+    return session.Put();
+}
+
+// Put async methods
+template <typename... Ts>
+AsyncResponse PutAsync(Ts... ts) {
+    return std::async(std::launch::async, [](Ts... ts) { return Put(std::move(ts)...); },
+                      std::move(ts)...);
+}
+
+// Put callback methods
+template <typename Then, typename... Ts>
+auto PutCallback(Then then, Ts... ts) -> std::future<decltype(then(Put(std::move(ts)...)))> {
+    return std::async(std::launch::async, [](Then then, Ts... ts) {
+        return then(Put(std::move(ts)...));
+    }, std::move(then), std::move(ts)...);
+}
+
+// Head methods
+template <typename... Ts>
+Response Head(Ts&&... ts) {
+    Session session;
+    priv::set_option(session, CPR_FWD(ts)...);
+    return session.Head();
+}
+
+// Head async methods
+template <typename... Ts>
+AsyncResponse HeadAsync(Ts... ts) {
+    return std::async(std::launch::async, [](Ts... ts) { return Head(std::move(ts)...); },
+                      std::move(ts)...);
+}
+
+// Head callback methods
+template <typename Then, typename... Ts>
+auto HeadCallback(Then then, Ts... ts) -> std::future<decltype(then(Head(std::move(ts)...)))> {
+    return std::async(std::launch::async, [](Then then, Ts... ts) {
+        return then(Head(std::move(ts)...));
+    }, std::move(then), std::move(ts)...);
+}
+
+// Delete methods
+template <typename... Ts>
+Response Delete(Ts&&... ts) {
+    Session session;
+    priv::set_option(session, CPR_FWD(ts)...);
+    return session.Delete();
+}
+
+// Delete async methods
+template <typename... Ts>
+AsyncResponse DeleteAsync(Ts... ts) {
+    return std::async(std::launch::async, [](Ts... ts) { return Delete(std::move(ts)...); },
+                      std::move(ts)...);
+}
+
+// Delete callback methods
+template <typename Then, typename... Ts>
+auto DeleteCallback(Then then, Ts... ts) -> std::future<decltype(then(Delete(std::move(ts)...)))> {
+    return std::async(std::launch::async, [](Then then, Ts... ts) {
+        return then(Delete(std::move(ts)...));
+    }, std::move(then), std::move(ts)...);
+}
+
+// Options methods
+template <typename... Ts>
+Response Options(Ts&&... ts) {
+    Session session;
+    priv::set_option(session, CPR_FWD(ts)...);
+    return session.Options();
+}
+
+// Options async methods
+template <typename... Ts>
+AsyncResponse OptionsAsync(Ts... ts) {
+    return std::async(std::launch::async, [](Ts... ts) { return Options(std::move(ts)...); },
+                      std::move(ts)...);
+}
+
+// Options callback methods
+template <typename Then, typename... Ts>
+auto OptionsCallback(Then then, Ts... ts)
+        -> std::future<decltype(then(Options(std::move(ts)...)))> {
+    return std::async(std::launch::async, [](Then then, Ts... ts) {
+        return then(Options(std::move(ts)...));
+    }, std::move(then), std::move(ts)...);
+}
+
+// Patch methods
+template <typename... Ts>
+Response Patch(Ts&&... ts) {
+    Session session;
+    priv::set_option(session, CPR_FWD(ts)...);
+    return session.Patch();
+}
+
+// Patch async methods
+template <typename... Ts>
+AsyncResponse PatchAsync(Ts... ts) {
+    return std::async(std::launch::async, [](Ts... ts) { return Patch(std::move(ts)...); },
+                      std::move(ts)...);
+}
+
+// Patch callback methods
+template <typename Then, typename... Ts>
+auto PatchCallback(Then then, Ts... ts) -> std::future<decltype(then(Patch(std::move(ts)...)))> {
+    return std::async(std::launch::async, [](Then then, Ts... ts) {
+        return then(Patch(std::move(ts)...));
+    }, std::move(then), std::move(ts)...);
+}
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/auth.h b/cpr/include/cpr/auth.h
new file mode 100644
index 0000000..9673164
--- /dev/null
+++ b/cpr/include/cpr/auth.h
@@ -0,0 +1,27 @@
+#ifndef CPR_AUTH_H
+#define CPR_AUTH_H
+
+#include <string>
+
+#include "cpr/defines.h"
+
+namespace cpr {
+
+class Authentication {
+  public:
+    template <typename UserType, typename PassType>
+    Authentication(UserType&& username, PassType&& password)
+            : username_{CPR_FWD(username)}, password_{CPR_FWD(password)},
+              auth_string_{username_ + ":" + password_} {}
+
+    const char* GetAuthString() const noexcept;
+
+  private:
+    std::string username_;
+    std::string password_;
+    std::string auth_string_;
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/body.h b/cpr/include/cpr/body.h
new file mode 100644
index 0000000..34c5b36
--- /dev/null
+++ b/cpr/include/cpr/body.h
@@ -0,0 +1,35 @@
+#ifndef CPR_BODY_H
+#define CPR_BODY_H
+
+#include <cstring>
+
+#include <initializer_list>
+#include <string>
+
+#include "cpr/defines.h"
+
+namespace cpr {
+
+class Body : public std::string {
+  public:
+    Body() = default;
+    Body(const Body& rhs) = default;
+    Body(Body&& rhs) = default;
+    Body& operator=(const Body& rhs) = default;
+    Body& operator=(Body&& rhs) = default;
+    explicit Body(const char* raw_string) : std::string(raw_string) {}
+    explicit Body(const char* raw_string, size_t length) : std::string(raw_string, length) {}
+    explicit Body(size_t to_fill, char character) : std::string(to_fill, character) {}
+    explicit Body(const std::string& std_string) : std::string(std_string) {}
+    explicit Body(const std::string& std_string, size_t position, size_t length = std::string::npos)
+            : std::string(std_string, position, length) {}
+    explicit Body(std::string&& std_string) : std::string(std::move(std_string)) {}
+    explicit Body(std::initializer_list<char> il) : std::string(il) {}
+    template <class InputIterator>
+    explicit Body(InputIterator first, InputIterator last)
+            : std::string(first, last) {}
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/cookies.h b/cpr/include/cpr/cookies.h
new file mode 100644
index 0000000..c0c3251
--- /dev/null
+++ b/cpr/include/cpr/cookies.h
@@ -0,0 +1,26 @@
+#ifndef CPR_COOKIES_H
+#define CPR_COOKIES_H
+
+#include <initializer_list>
+#include <map>
+#include <sstream>
+#include <string>
+
+namespace cpr {
+
+class Cookies {
+  public:
+    Cookies() {}
+    Cookies(const std::initializer_list<std::pair<const std::string, std::string>>& pairs);
+    Cookies(const std::map<std::string, std::string>& map) : map_{map} {}
+
+    std::string& operator[](const std::string& key);
+    std::string GetEncoded() const;
+
+  private:
+    std::map<std::string, std::string> map_;
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/cpr.h b/cpr/include/cpr/cpr.h
new file mode 100644
index 0000000..9fcc3fd
--- /dev/null
+++ b/cpr/include/cpr/cpr.h
@@ -0,0 +1,10 @@
+#ifndef CPR_CPR_H
+#define CPR_CPR_H
+
+#include "cpr/api.h"
+#include "cpr/auth.h"
+#include "cpr/cprtypes.h"
+#include "cpr/response.h"
+#include "cpr/session.h"
+
+#endif
diff --git a/cpr/include/cpr/cprtypes.h b/cpr/include/cpr/cprtypes.h
new file mode 100644
index 0000000..37e6ff4
--- /dev/null
+++ b/cpr/include/cpr/cprtypes.h
@@ -0,0 +1,18 @@
+#ifndef CPR_CPR_TYPES_H
+#define CPR_CPR_TYPES_H
+
+#include <map>
+#include <string>
+
+namespace cpr {
+
+struct CaseInsensitiveCompare {
+    bool operator()(const std::string& a, const std::string& b) const noexcept;
+};
+
+using Header = std::map<std::string, std::string, CaseInsensitiveCompare>;
+using Url = std::string;
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/curlholder.h b/cpr/include/cpr/curlholder.h
new file mode 100644
index 0000000..2f9825e
--- /dev/null
+++ b/cpr/include/cpr/curlholder.h
@@ -0,0 +1,19 @@
+#ifndef CPR_CURL_HOLDER_H
+#define CPR_CURL_HOLDER_H
+
+#include <memory>
+
+#include <curl/curl.h>
+
+namespace cpr {
+
+struct CurlHolder {
+    CURL* handle;
+    struct curl_slist* chunk;
+    struct curl_httppost* formpost;
+    char error[CURL_ERROR_SIZE];
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/defines.h b/cpr/include/cpr/defines.h
new file mode 100644
index 0000000..b08575c
--- /dev/null
+++ b/cpr/include/cpr/defines.h
@@ -0,0 +1,8 @@
+#ifndef CPR_DEFINES_H
+#define CPR_DEFINES_H
+
+#include <utility>
+
+#define CPR_FWD(...) ::std::forward<decltype(__VA_ARGS__)>(__VA_ARGS__)
+
+#endif
diff --git a/cpr/include/cpr/digest.h b/cpr/include/cpr/digest.h
new file mode 100644
index 0000000..0a8e68a
--- /dev/null
+++ b/cpr/include/cpr/digest.h
@@ -0,0 +1,20 @@
+#ifndef CPR_DIGEST_H
+#define CPR_DIGEST_H
+
+#include "cpr/auth.h"
+#include "cpr/defines.h"
+
+namespace cpr {
+
+class Digest : public Authentication {
+  public:
+    template <typename UserType, typename PassType>
+    Digest(UserType&& username, PassType&& password)
+            : Authentication{CPR_FWD(username), CPR_FWD(password)} {}
+
+    const char* GetAuthString() const noexcept;
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/error.h b/cpr/include/cpr/error.h
new file mode 100644
index 0000000..7cf8d99
--- /dev/null
+++ b/cpr/include/cpr/error.h
@@ -0,0 +1,53 @@
+#ifndef CPR_ERROR_H
+#define CPR_ERROR_H
+
+#include <cstdint>
+#include <string>
+
+#include "cpr/cprtypes.h"
+#include "cpr/defines.h"
+
+namespace cpr {
+
+enum class ErrorCode {
+    OK = 0,
+    CONNECTION_FAILURE,
+    EMPTY_RESPONSE,
+    HOST_RESOLUTION_FAILURE,
+    INTERNAL_ERROR,
+    INVALID_URL_FORMAT,
+    NETWORK_RECEIVE_ERROR,
+    NETWORK_SEND_FAILURE,
+    OPERATION_TIMEDOUT,
+    PROXY_RESOLUTION_FAILURE,
+    SSL_CONNECT_ERROR,
+    SSL_LOCAL_CERTIFICATE_ERROR,
+    SSL_REMOTE_CERTIFICATE_ERROR,
+    SSL_CACERT_ERROR,
+    GENERIC_SSL_ERROR,
+    UNSUPPORTED_PROTOCOL,
+    UNKNOWN_ERROR = 1000,
+};
+
+class Error {
+  public:
+    Error() : code{ErrorCode::OK} {}
+
+    template <typename TextType>
+    Error(const std::int32_t& curl_code, TextType&& p_error_message)
+            : code{getErrorCodeForCurlError(curl_code)}, message{CPR_FWD(p_error_message)} {}
+
+    explicit operator bool() const {
+        return code != ErrorCode::OK;
+    }
+
+    ErrorCode code;
+    std::string message;
+
+  private:
+    static ErrorCode getErrorCodeForCurlError(std::int32_t curl_code);
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/low_speed.h b/cpr/include/cpr/low_speed.h
new file mode 100644
index 0000000..394a438
--- /dev/null
+++ b/cpr/include/cpr/low_speed.h
@@ -0,0 +1,18 @@
+#ifndef CPR_LOW_SPEED_H
+#define CPR_LOW_SPEED_H
+
+#include <cstdint>
+
+namespace cpr {
+
+class LowSpeed {
+  public:
+    LowSpeed(const std::int32_t limit, const std::int32_t time) : limit(limit), time(time) {}
+
+    std::int32_t limit;
+    std::int32_t time;
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/max_redirects.h b/cpr/include/cpr/max_redirects.h
new file mode 100644
index 0000000..4d3dea4
--- /dev/null
+++ b/cpr/include/cpr/max_redirects.h
@@ -0,0 +1,18 @@
+#ifndef CPR_MAX_REDIRECTS_H
+#define CPR_MAX_REDIRECTS_H
+
+#include <cstdint>
+
+namespace cpr {
+
+class MaxRedirects {
+  public:
+    explicit MaxRedirects(const std::int32_t number_of_redirects)
+            : number_of_redirects(number_of_redirects) {}
+
+    std::int32_t number_of_redirects;
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/multipart.h b/cpr/include/cpr/multipart.h
new file mode 100644
index 0000000..ba2c9ab
--- /dev/null
+++ b/cpr/include/cpr/multipart.h
@@ -0,0 +1,75 @@
+#ifndef CPR_MULTIPART_H
+#define CPR_MULTIPART_H
+
+#include <cstdint>
+#include <initializer_list>
+#include <string>
+#include <type_traits>
+#include <vector>
+
+#include "cpr/defines.h"
+
+namespace cpr {
+
+struct File {
+    template <typename StringType>
+    explicit File(StringType&& filepath)
+            : filepath{CPR_FWD(filepath)} {}
+    std::string filepath;
+};
+
+struct Buffer {
+    typedef const unsigned char* data_t;
+
+    template <typename Iterator, typename StringType>
+    explicit Buffer(Iterator begin, Iterator end, StringType&& filename)
+            : data{reinterpret_cast<data_t>(&(*begin))},
+              datalen{static_cast<unsigned long>(std::distance(begin, end))},
+              filename{CPR_FWD(filename)} {
+        is_random_access_iterator(begin, end);
+        static_assert(sizeof(*begin) == 1, "only byte buffers can be used");
+    }
+
+    template <typename Iterator>
+    typename std::enable_if<std::is_same<typename std::iterator_traits<Iterator>::iterator_category,
+                                         std::random_access_iterator_tag>::value>::type
+    is_random_access_iterator(Iterator /* begin */, Iterator /* end */ ) {}
+
+    data_t data;
+    unsigned long datalen;
+    std::string filename;
+};
+
+struct Part {
+    Part(const std::string& name, const std::string& value, const std::string& content_type = {})
+            : name{name}, value{value}, content_type{content_type}, is_file{false},
+              is_buffer{false} {}
+    Part(const std::string& name, const std::int32_t& value, const std::string& content_type = {})
+            : name{name}, value{std::to_string(value)}, content_type{content_type}, is_file{false},
+              is_buffer{false} {}
+    Part(const std::string& name, const File& file, const std::string& content_type = {})
+            : name{name}, value{file.filepath}, content_type{content_type}, is_file{true},
+              is_buffer{false} {}
+    Part(const std::string& name, const Buffer& buffer, const std::string& content_type = {})
+            : name{name}, value{buffer.filename}, content_type{content_type}, data{buffer.data},
+              datalen{buffer.datalen}, is_file{false}, is_buffer{true} {}
+
+    std::string name;
+    std::string value;
+    std::string content_type;
+    Buffer::data_t data;
+    unsigned long datalen;
+    bool is_file;
+    bool is_buffer;
+};
+
+class Multipart {
+  public:
+    Multipart(const std::initializer_list<Part>& parts);
+
+    std::vector<Part> parts;
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/parameters.h b/cpr/include/cpr/parameters.h
new file mode 100644
index 0000000..4e36685
--- /dev/null
+++ b/cpr/include/cpr/parameters.h
@@ -0,0 +1,33 @@
+#ifndef CPR_PARAMETERS_H
+#define CPR_PARAMETERS_H
+
+#include <initializer_list>
+#include <memory>
+#include <string>
+
+#include "cpr/defines.h"
+
+namespace cpr {
+
+struct Parameter {
+    template <typename KeyType, typename ValueType>
+    Parameter(KeyType&& key, ValueType&& value)
+            : key{CPR_FWD(key)}, value{CPR_FWD(value)} {}
+
+    std::string key;
+    std::string value;
+};
+
+class Parameters {
+  public:
+    Parameters() = default;
+    Parameters(const std::initializer_list<Parameter>& parameters);
+
+    void AddParameter(const Parameter& parameter);
+
+    std::string content;
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/payload.h b/cpr/include/cpr/payload.h
new file mode 100644
index 0000000..a183a61
--- /dev/null
+++ b/cpr/include/cpr/payload.h
@@ -0,0 +1,43 @@
+#ifndef CPR_PAYLOAD_H
+#define CPR_PAYLOAD_H
+
+#include <cstdint>
+#include <initializer_list>
+#include <memory>
+#include <string>
+
+#include "cpr/defines.h"
+
+namespace cpr {
+
+struct Pair {
+    template <typename KeyType, typename ValueType,
+              typename std::enable_if<!std::is_integral<ValueType>::value, bool>::type = true>
+    Pair(KeyType&& p_key, ValueType&& p_value)
+            : key{CPR_FWD(p_key)}, value{CPR_FWD(p_value)} {}
+    template <typename KeyType>
+    Pair(KeyType&& p_key, const std::int32_t& p_value)
+            : key{CPR_FWD(p_key)}, value{std::to_string(p_value)} {}
+
+    std::string key;
+    std::string value;
+};
+
+class Payload {
+  public:
+    template <class It>
+    Payload(const It begin, const It end) {
+        for (It pair = begin; pair != end; ++pair) {
+            AddPair(*pair);
+        }
+    }
+    Payload(const std::initializer_list<Pair>& pairs);
+
+    void AddPair(const Pair& pair);
+
+    std::string content;
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/proxies.h b/cpr/include/cpr/proxies.h
new file mode 100644
index 0000000..ba68fa5
--- /dev/null
+++ b/cpr/include/cpr/proxies.h
@@ -0,0 +1,25 @@
+#ifndef CPR_PROXIES_H
+#define CPR_PROXIES_H
+
+#include <initializer_list>
+#include <map>
+#include <string>
+#include <utility>
+
+namespace cpr {
+
+class Proxies {
+  public:
+    Proxies() {}
+    Proxies(const std::initializer_list<std::pair<const std::string, std::string>>& hosts);
+
+    bool has(const std::string& protocol) const;
+    const std::string& operator[](const std::string& protocol);
+
+  private:
+    std::map<std::string, std::string> hosts_;
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/response.h b/cpr/include/cpr/response.h
new file mode 100644
index 0000000..c3b0c3c
--- /dev/null
+++ b/cpr/include/cpr/response.h
@@ -0,0 +1,38 @@
+#ifndef CPR_RESPONSE_H
+#define CPR_RESPONSE_H
+
+#include <cstdint>
+#include <string>
+
+#include "cpr/cookies.h"
+#include "cpr/cprtypes.h"
+#include "cpr/defines.h"
+#include "cpr/error.h"
+
+namespace cpr {
+
+class Response {
+  public:
+    Response() = default;
+
+    template <typename TextType, typename HeaderType, typename UrlType, typename CookiesType,
+              typename ErrorType>
+    Response(const std::int32_t& p_status_code, TextType&& p_text, HeaderType&& p_header, UrlType&& p_url,
+             const double& p_elapsed, CookiesType&& p_cookies = Cookies{},
+             ErrorType&& p_error = Error{})
+            : status_code{p_status_code}, text{CPR_FWD(p_text)}, header{CPR_FWD(p_header)},
+              url{CPR_FWD(p_url)}, elapsed{p_elapsed}, cookies{CPR_FWD(p_cookies)},
+              error{CPR_FWD(p_error)} {}
+
+    std::int32_t status_code;
+    std::string text;
+    Header header;
+    Url url;
+    double elapsed;
+    Cookies cookies;
+    Error error;
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/session.h b/cpr/include/cpr/session.h
new file mode 100644
index 0000000..bf6b671
--- /dev/null
+++ b/cpr/include/cpr/session.h
@@ -0,0 +1,87 @@
+#ifndef CPR_SESSION_H
+#define CPR_SESSION_H
+
+#include <cstdint>
+#include <memory>
+
+#include "cpr/auth.h"
+#include "cpr/body.h"
+#include "cpr/cookies.h"
+#include "cpr/cprtypes.h"
+#include "cpr/digest.h"
+#include "cpr/max_redirects.h"
+#include "cpr/multipart.h"
+#include "cpr/parameters.h"
+#include "cpr/payload.h"
+#include "cpr/proxies.h"
+#include "cpr/response.h"
+#include "cpr/timeout.h"
+#include "cpr/low_speed.h"
+#include "cpr/ssl_options.h"
+
+namespace cpr {
+
+class Session {
+  public:
+    Session();
+    ~Session();
+
+    void SetUrl(const Url& url);
+    void SetParameters(const Parameters& parameters);
+    void SetParameters(Parameters&& parameters);
+    void SetHeader(const Header& header);
+    void SetTimeout(const Timeout& timeout);
+    void SetAuth(const Authentication& auth);
+    void SetDigest(const Digest& auth);
+    void SetPayload(Payload&& payload);
+    void SetPayload(const Payload& payload);
+    void SetProxies(Proxies&& proxies);
+    void SetProxies(const Proxies& proxies);
+    void SetMultipart(Multipart&& multipart);
+    void SetMultipart(const Multipart& multipart);
+    void SetRedirect(const bool& redirect);
+    void SetMaxRedirects(const MaxRedirects& max_redirects);
+    void SetCookies(const Cookies& cookies);
+    void SetBody(Body&& body);
+    void SetBody(const Body& body);
+    void SetLowSpeed(const LowSpeed& low_speed);
+    void SetVerifySsl(const VerifySsl& verify);
+
+    // Used in templated functions
+    void SetOption(const Url& url);
+    void SetOption(const Parameters& parameters);
+    void SetOption(Parameters&& parameters);
+    void SetOption(const Header& header);
+    void SetOption(const Timeout& timeout);
+    void SetOption(const Authentication& auth);
+    void SetOption(const Digest& auth);
+    void SetOption(Payload&& payload);
+    void SetOption(const Payload& payload);
+    void SetOption(Proxies&& proxies);
+    void SetOption(const Proxies& proxies);
+    void SetOption(Multipart&& multipart);
+    void SetOption(const Multipart& multipart);
+    void SetOption(const bool& redirect);
+    void SetOption(const MaxRedirects& max_redirects);
+    void SetOption(const Cookies& cookies);
+    void SetOption(Body&& body);
+    void SetOption(const Body& body);
+    void SetOption(const LowSpeed& low_speed);
+    void SetOption(const VerifySsl& verify);
+
+    Response Delete();
+    Response Get();
+    Response Head();
+    Response Options();
+    Response Patch();
+    Response Post();
+    Response Put();
+
+  private:
+    class Impl;
+    std::unique_ptr<Impl> pimpl_;
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/ssl_options.h b/cpr/include/cpr/ssl_options.h
new file mode 100644
index 0000000..ebee0df
--- /dev/null
+++ b/cpr/include/cpr/ssl_options.h
@@ -0,0 +1,19 @@
+#ifndef CPR_SSLOPTIONS_H
+#define CPR_SSLOPTIONS_H
+
+namespace cpr {
+
+class VerifySsl {
+  public:
+    VerifySsl() {}
+    VerifySsl(bool verify);
+
+    operator bool() const;
+
+  private:
+    bool verify_ = true;
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/timeout.h b/cpr/include/cpr/timeout.h
new file mode 100644
index 0000000..6e6fb79
--- /dev/null
+++ b/cpr/include/cpr/timeout.h
@@ -0,0 +1,21 @@
+#ifndef CPR_TIMEOUT_H
+#define CPR_TIMEOUT_H
+
+#include <chrono>
+#include <cstdint>
+
+namespace cpr {
+
+class Timeout {
+  public:
+    Timeout(const std::chrono::milliseconds& duration) : ms{duration} {}
+    Timeout(const std::int32_t& milliseconds) : Timeout{std::chrono::milliseconds(milliseconds)} {}
+
+    long Milliseconds() const;
+
+    std::chrono::milliseconds ms;
+};
+
+} // namespace cpr
+
+#endif
diff --git a/cpr/include/cpr/util.h b/cpr/include/cpr/util.h
new file mode 100644
index 0000000..7660d38
--- /dev/null
+++ b/cpr/include/cpr/util.h
@@ -0,0 +1,20 @@
+#ifndef CPR_UTIL_H
+#define CPR_UTIL_H
+
+#include <string>
+#include <vector>
+
+#include "cpr/cprtypes.h"
+
+namespace cpr {
+namespace util {
+
+Header parseHeader(const std::string& headers);
+size_t writeFunction(void* ptr, size_t size, size_t nmemb, std::string* data);
+std::vector<std::string> split(const std::string& to_split, char delimiter);
+std::string urlEncode(const std::string& response);
+
+} // namespace util
+} // namespace cpr
+
+#endif
diff --git a/cpr/opt/CMakeLists.txt b/cpr/opt/CMakeLists.txt
new file mode 100644
index 0000000..e5dabac
--- /dev/null
+++ b/cpr/opt/CMakeLists.txt
@@ -0,0 +1,115 @@
+macro(set_cache_variable VAR_NAME VAR_DESCRIPTION)
+    set(${VAR_NAME} ${${VAR_NAME}} CACHE INTERNAL ${VAR_DESCRIPTION})
+    message(STATUS "Set ${VAR_NAME} to ${${VAR_NAME}}.")
+endmacro()
+
+
+# Code coverage
+
+if(BUILD_CPR_TESTS AND GENERATE_COVERAGE)
+    set(CMAKE_BUILD_TYPE COVERAGE CACHE INTERNAL "Coverage enabled build")
+    message(STATUS "Enabling gcov support")
+    if(NOT "${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
+        set(COVERAGE_FLAG "--coverage")
+    endif()
+    set(CMAKE_CXX_FLAGS_COVERAGE
+        "-g -O0 ${COVERAGE_FLAG} -fprofile-arcs -ftest-coverage"
+        CACHE STRING "Flags used by the C++ compiler during coverage builds."
+        FORCE)
+    set(CMAKE_C_FLAGS_COVERAGE
+        "-g -O0 ${COVERAGE_FLAG} -fprofile-arcs -ftest-coverage"
+        CACHE STRING "Flags used by the C compiler during coverage builds."
+        FORCE)
+    set(CMAKE_EXE_LINKER_FLAGS_COVERAGE
+        ""
+        CACHE STRING "Flags used for linking binaries during coverage builds."
+        FORCE)
+    set(CMAKE_SHARED_LINKER_FLAGS_COVERAGE
+        ""
+        CACHE STRING "Flags used by the shared libraries linker during coverage builds."
+        FORCE)
+    mark_as_advanced(
+        CMAKE_CXX_FLAGS_COVERAGE
+        CMAKE_C_FLAGS_COVERAGE
+        CMAKE_EXE_LINKER_FLAGS_COVERAGE
+        CMAKE_SHARED_LINKER_FLAGS_COVERAGE)
+endif()
+
+
+# Curl configuration
+
+if(USE_SYSTEM_CURL)
+    find_package(CURL)
+endif()
+if(NOT USE_SYSTEM_CURL OR NOT CURL_FOUND)
+    message(STATUS "Not using system Curl, using built-in curl project instead.")
+    option(BUILD_TESTING "Set to ON to build cURL tests." OFF)
+    option(BUILD_CURL_EXE "Set to ON to build cURL executable." OFF)
+    add_subdirectory(curl)
+    set(CURL_FOUND TRUE)
+    set(CURL_LIBRARIES libcurl)
+    set(CURL_INCLUDE_DIRS
+        ${CURL_SOURCE_DIR}/include
+        ${CURL_BINARY_DIR}/include/curl)
+
+    # Group under the "external" project folder in IDEs such as Visual Studio.
+    if(BUILD_CURL_EXE)
+        set_property(TARGET curl PROPERTY FOLDER "external")
+    endif()
+    set_property(TARGET libcurl PROPERTY FOLDER "external")
+endif()
+
+set_cache_variable(CURL_FOUND "Set if libcurl is found or built")
+set_cache_variable(CURL_LIBRARIES "Location of libcurl")
+set_cache_variable(CURL_INCLUDE_DIRS "Location of curl include files")
+
+
+# GTest configuration
+
+if(BUILD_CPR_TESTS)
+    if(USE_SYSTEM_GTEST)
+        find_package(GTest)
+    endif()
+    if(NOT USE_SYSTEM_GTEST OR NOT GTEST_FOUND)
+        message(STATUS "Not using system gtest, using built-in googletest project instead.")
+        if(MSVC)
+            # By default, GTest compiles on Windows in CRT static linkage mode. We use this
+            # variable to force it into using the CRT in dynamic linkage (DLL), just as CPR
+            # does.
+            set(gtest_force_shared_crt ON CACHE BOOL "Force gtest to use the shared c runtime")
+        endif()
+        add_subdirectory(googletest)
+        set(GTEST_FOUND TRUE)
+        set(GTEST_LIBRARIES gtest)
+        set(GTEST_MAIN_LIBRARIES gtest_main)
+        set(GTEST_BOTH_LIBRARIES gtest gtest_main)
+        set(GTEST_INCLUDE_DIRS ${gtest_SOURCE_DIR}/include)
+
+        # Group under the "tests/gtest" project folder in IDEs such as Visual Studio.
+    set_property(TARGET gtest PROPERTY FOLDER "tests/gtest")
+    set_property(TARGET gtest_main PROPERTY FOLDER "tests/gtest")
+    endif()
+
+    set_cache_variable(GTEST_FOUND "Set if libgtest was found or built")
+    set_cache_variable(GTEST_LIBRARIES "Location of libgtest")
+    set_cache_variable(GTEST_MAIN_LIBRARIES "Location of libgtest-main")
+    set_cache_variable(GTEST_BOTH_LIBRARIES "Location of both gtest libraries")
+    set_cache_variable(GTEST_INCLUDE_DIRS "Location of gtest include files")
+endif()
+
+
+# Mongoose configuration
+
+if(BUILD_CPR_TESTS)
+    message(STATUS "Building mongoose project for test support.")
+    add_subdirectory(mongoose)
+    set(MONGOOSE_FOUND TRUE)
+    set(MONGOOSE_LIBRARIES mongoose)
+    set(MONGOOSE_INCLUDE_DIRS ${mongoose_SOURCE_DIR})
+
+    set_cache_variable(MONGOOSE_FOUND "Set if libmongoose was found or built")
+    set_cache_variable(MONGOOSE_LIBRARIES "Location of libmongoose")
+    set_cache_variable(MONGOOSE_INCLUDE_DIRS "Location of mongoose include files")
+    # Group under the "external" project folder in IDEs such as Visual Studio.
+    set_property(TARGET mongoose PROPERTY FOLDER "external")
+endif()
diff --git a/cpr/test/CMakeLists.txt b/cpr/test/CMakeLists.txt
new file mode 100644
index 0000000..c5c001f
--- /dev/null
+++ b/cpr/test/CMakeLists.txt
@@ -0,0 +1,51 @@
+find_package(Threads)
+set(TEST_SERVER_LIBRARY test_server)
+add_library(${TEST_SERVER_LIBRARY}
+    server.cpp)
+target_link_libraries(${TEST_SERVER_LIBRARY}
+    ${MONGOOSE_LIBRARIES}
+    ${CMAKE_THREAD_LIBS_INIT})
+
+macro(add_cpr_test _TEST_NAME)
+    add_executable(${_TEST_NAME}_tests
+        ${_TEST_NAME}_tests.cpp)
+    target_link_libraries(${_TEST_NAME}_tests
+        ${TEST_SERVER_LIBRARY}
+        ${GTEST_LIBRARIES}
+        ${CPR_LIBRARIES})
+    add_test(NAME cpr_${_TEST_NAME}_tests COMMAND ${_TEST_NAME}_tests)
+    # Group under the "tests" project folder in IDEs such as Visual Studio.
+    set_property(TARGET ${_TEST_NAME}_tests PROPERTY FOLDER "tests")
+    if(WIN32)
+        set(LIBCURL_DLL_NAME "libcurl.dll")
+        if(CMAKE_BUILD_TYPE STREQUAL "DEBUG")
+            set(LIBCURL_DLL_NAME "libcurl-d.dll")
+        endif()
+        add_custom_command(TARGET ${_TEST_NAME}_tests POST_BUILD
+                           COMMAND ${CMAKE_COMMAND} -E copy
+                                $<TARGET_FILE_DIR:libcurl>/${LIBCURL_DLL_NAME} $<TARGET_FILE_DIR:${_TEST_NAME}_tests>)
+    endif()
+endmacro()
+
+include_directories(
+    ${CURL_INCLUDE_DIRS}
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CPR_INCLUDE_DIRS}
+    ${GTEST_INCLUDE_DIRS}
+    ${MONGOOSE_INCLUDE_DIRS})
+
+add_cpr_test(get)
+add_cpr_test(post)
+add_cpr_test(session)
+add_cpr_test(async)
+add_cpr_test(proxy)
+add_cpr_test(head)
+add_cpr_test(delete)
+add_cpr_test(put)
+add_cpr_test(callback)
+add_cpr_test(raw_body)
+add_cpr_test(options)
+add_cpr_test(patch)
+add_cpr_test(error)
+add_cpr_test(alternating)
+add_cpr_test(util)
diff --git a/cpr/test/alternating_tests.cpp b/cpr/test/alternating_tests.cpp
new file mode 100644
index 0000000..952e13c
--- /dev/null
+++ b/cpr/test/alternating_tests.cpp
@@ -0,0 +1,164 @@
+#include <gtest/gtest.h>
+
+#include <string>
+
+#include <cpr/cpr.h>
+
+#include "server.h"
+
+using namespace cpr;
+
+static Server* server = new Server();
+auto base = server->GetBaseUrl();
+
+TEST(AlternatingTests, PutGetTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    Session session;
+    session.SetUrl(url);
+
+    {
+        auto payload = Payload{{"x", "5"}};
+        auto response = cpr::Put(url, payload);
+        auto expected_text = std::string{"Header reflect PUT"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+
+    {
+        auto response = cpr::Get(url);
+        auto expected_text = std::string{"Header reflect GET"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(AlternatingTests, PutGetPutGetTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    Session session;
+    session.SetUrl(url);
+
+    {
+        auto payload = Payload{{"x", "5"}};
+        auto response = cpr::Put(url, payload);
+        auto expected_text = std::string{"Header reflect PUT"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+
+    {
+        auto response = cpr::Get(url);
+        auto expected_text = std::string{"Header reflect GET"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+
+    {
+        auto payload = Payload{{"x", "5"}};
+        auto response = cpr::Put(url, payload);
+        auto expected_text = std::string{"Header reflect PUT"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+
+    {
+        auto response = cpr::Get(url);
+        auto expected_text = std::string{"Header reflect GET"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(AlternatingTests, HeadGetTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    Session session;
+    session.SetUrl(url);
+
+    {
+        // Head shouldn't return a body
+        auto response = cpr::Head(url);
+        auto expected_text = std::string{""};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+
+    {
+        auto response = cpr::Get(url);
+        auto expected_text = std::string{"Header reflect GET"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(AlternatingTests, PutHeadTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    Session session;
+    session.SetUrl(url);
+
+    {
+        auto payload = Payload{{"x", "5"}};
+        auto response = cpr::Put(url, payload);
+        auto expected_text = std::string{"Header reflect PUT"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+
+    {
+        // Head shouldn't return a body
+        auto response = cpr::Head(url);
+        auto expected_text = std::string{""};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(AlternatingTests, PutPostTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    Session session;
+    session.SetUrl(url);
+
+    {
+        auto payload = Payload{{"x", "5"}};
+        auto response = cpr::Put(url, payload);
+        auto expected_text = std::string{"Header reflect PUT"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+
+    {
+        auto payload = Payload{{"x", "5"}};
+        auto response = cpr::Post(url, payload);
+        auto expected_text = std::string{"Header reflect POST"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    ::testing::AddGlobalTestEnvironment(server);
+    return RUN_ALL_TESTS();
+}
diff --git a/cpr/test/async_tests.cpp b/cpr/test/async_tests.cpp
new file mode 100644
index 0000000..06a573b
--- /dev/null
+++ b/cpr/test/async_tests.cpp
@@ -0,0 +1,65 @@
+#include <gtest/gtest.h>
+
+#include <string>
+#include <vector>
+
+#include <cpr/cpr.h>
+
+#include "server.h"
+
+
+static Server* server = new Server();
+auto base = server->GetBaseUrl();
+
+TEST(UrlEncodedPostTests, AsyncGetTest) {
+    auto url = Url{base + "/hello.html"};
+    auto future = cpr::GetAsync(url);
+    auto expected_text = std::string{"Hello world!"};
+    auto response = future.get();
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+}
+
+TEST(UrlEncodedPostTests, AsyncGetMultipleTest) {
+    auto url = Url{base + "/hello.html"};
+    std::vector<AsyncResponse> responses;
+    for (int i = 0; i < 10; ++i) {
+        responses.emplace_back(cpr::GetAsync(url));
+    }
+    for (auto& future : responses) {
+        auto expected_text = std::string{"Hello world!"};
+        auto response = future.get();
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+    }
+}
+
+TEST(UrlEncodedPostTests, AsyncGetMultipleReflectTest) {
+    auto url = Url{base + "/hello.html"};
+    std::vector<AsyncResponse> responses;
+    for (int i = 0; i < 100; ++i) {
+        auto p = Parameters{{"key", std::to_string(i)}};
+        responses.emplace_back(cpr::GetAsync(url, p));
+    }
+    int i = 0;
+    for (auto& future : responses) {
+        auto expected_text = std::string{"Hello world!"};
+        auto response = future.get();
+        EXPECT_EQ(expected_text, response.text);
+        auto expected_url = Url{url + "?key=" + std::to_string(i)};
+        EXPECT_EQ(expected_url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        ++i;
+    }
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    ::testing::AddGlobalTestEnvironment(server);
+    return RUN_ALL_TESTS();
+}
diff --git a/cpr/test/callback_tests.cpp b/cpr/test/callback_tests.cpp
new file mode 100644
index 0000000..f2bf685
--- /dev/null
+++ b/cpr/test/callback_tests.cpp
@@ -0,0 +1,730 @@
+#include <gtest/gtest.h>
+
+#include <string>
+#include <vector>
+
+#include <cpr/cpr.h>
+
+#include "server.h"
+
+using namespace cpr;
+
+static Server* server = new Server();
+auto base = server->GetBaseUrl();
+auto sleep_time = std::chrono::milliseconds(50);
+auto zero = std::chrono::seconds(0);
+
+int status_callback(int& status_code, Response r) {
+    status_code = r.status_code;
+    return r.status_code;
+}
+
+int status_callback_ref(int& status_code, const Response& r) {
+    status_code = r.status_code;
+    return r.status_code;
+}
+
+std::string text_callback(std::string& expected_text, Response r) {
+    expected_text = r.text;
+    return r.text;
+}
+
+std::string text_callback_ref(std::string& expected_text, const Response& r) {
+    expected_text = r.text;
+    return r.text;
+}
+
+TEST(CallbackGetTests, CallbackGetLambdaStatusTest) {
+    auto url = Url{base + "/hello.html"};
+    auto status_code = 0;
+    auto future = cpr::GetCallback([&status_code] (Response r) {
+                status_code = r.status_code;
+                return r.status_code;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackGetTests, CallbackGetLambdaTextTest) {
+    auto url = Url{base + "/hello.html"};
+    auto expected_text = std::string{};
+    auto future = cpr::GetCallback([&expected_text] (Response r) {
+                expected_text = r.text;
+                return r.text;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackGetTests, CallbackGetLambdaStatusReferenceTest) {
+    auto url = Url{base + "/hello.html"};
+    auto status_code = 0;
+    auto future = cpr::GetCallback([&status_code] (const Response& r) {
+                status_code = r.status_code;
+                return r.status_code;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackGetTests, CallbackGetLambdaTextReferenceTest) {
+    auto url = Url{base + "/hello.html"};
+    auto expected_text = std::string{};
+    auto future = cpr::GetCallback([&expected_text] (const Response& r) {
+                expected_text = r.text;
+                return r.text;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackGetTests, CallbackGetFunctionStatusTest) {
+    auto url = Url{base + "/hello.html"};
+    auto status_code = 0;
+    auto callback = std::function<int(Response)>(std::bind(status_callback, std::ref(status_code),
+                                                           std::placeholders::_1));
+    auto future = cpr::GetCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackGetTests, CallbackGetFunctionTextTest) {
+    auto url = Url{base + "/hello.html"};
+    auto expected_text = std::string{};
+    auto callback = std::function<std::string(Response)>(std::bind(text_callback,
+                                                                   std::ref(expected_text),
+                                                                   std::placeholders::_1));
+    auto future = cpr::GetCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackGetTests, CallbackGetFunctionStatusReferenceTest) {
+    auto url = Url{base + "/hello.html"};
+    auto status_code = 0;
+    auto callback = std::function<int(Response)>(std::bind(status_callback_ref,
+                                                           std::ref(status_code),
+                                                           std::placeholders::_1));
+    auto future = cpr::GetCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackGetTests, CallbackGetFunctionTextReferenceTest) {
+    auto url = Url{base + "/hello.html"};
+    auto expected_text = std::string{};
+    auto callback = std::function<std::string(Response)>(std::bind(text_callback_ref,
+                                                                   std::ref(expected_text),
+                                                                   std::placeholders::_1));
+    auto future = cpr::GetCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackDeleteTests, CallbackDeleteLambdaStatusTest) {
+    auto url = Url{base + "/delete.html"};
+    auto status_code = 0;
+    auto future = cpr::DeleteCallback([&status_code] (Response r) {
+                status_code = r.status_code;
+                return r.status_code;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackDeleteTests, CallbackDeleteLambdaTextTest) {
+    auto url = Url{base + "/delete.html"};
+    auto expected_text = std::string{};
+    auto future = cpr::DeleteCallback([&expected_text] (Response r) {
+                expected_text = r.text;
+                return r.text;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackDeleteTests, CallbackDeleteLambdaStatusReferenceTest) {
+    auto url = Url{base + "/delete.html"};
+    auto status_code = 0;
+    auto future = cpr::DeleteCallback([&status_code] (const Response& r) {
+                status_code = r.status_code;
+                return r.status_code;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackDeleteTests, CallbackDeleteLambdaTextReferenceTest) {
+    auto url = Url{base + "/delete.html"};
+    auto expected_text = std::string{};
+    auto future = cpr::DeleteCallback([&expected_text] (const Response& r) {
+                expected_text = r.text;
+                return r.text;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackDeleteTests, CallbackDeleteFunctionStatusTest) {
+    auto url = Url{base + "/delete.html"};
+    auto status_code = 0;
+    auto callback = std::function<int(Response)>(std::bind(status_callback, std::ref(status_code),
+                                                           std::placeholders::_1));
+    auto future = cpr::DeleteCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackDeleteTests, CallbackDeleteFunctionTextTest) {
+    auto url = Url{base + "/delete.html"};
+    auto expected_text = std::string{};
+    auto callback = std::function<std::string(Response)>(std::bind(text_callback,
+                                                                   std::ref(expected_text),
+                                                                   std::placeholders::_1));
+    auto future = cpr::DeleteCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackDeleteTests, CallbackDeleteFunctionStatusReferenceTest) {
+    auto url = Url{base + "/delete.html"};
+    auto status_code = 0;
+    auto callback = std::function<int(Response)>(std::bind(status_callback_ref,
+                                                           std::ref(status_code),
+                                                           std::placeholders::_1));
+    auto future = cpr::DeleteCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackDeleteTests, CallbackDeleteFunctionTextReferenceTest) {
+    auto url = Url{base + "/delete.html"};
+    auto expected_text = std::string{};
+    auto callback = std::function<std::string(Response)>(std::bind(text_callback_ref,
+                                                                   std::ref(expected_text),
+                                                                   std::placeholders::_1));
+    auto future = cpr::DeleteCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackHeadTests, CallbackHeadLambdaStatusTest) {
+    auto url = Url{base + "/hello.html"};
+    auto status_code = 0;
+    auto future = cpr::HeadCallback([&status_code] (Response r) {
+                status_code = r.status_code;
+                return r.status_code;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackHeadTests, CallbackHeadLambdaTextTest) {
+    auto url = Url{base + "/hello.html"};
+    auto expected_text = std::string{};
+    auto future = cpr::HeadCallback([&expected_text] (Response r) {
+                expected_text = r.text;
+                return r.text;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackHeadTests, CallbackHeadLambdaStatusReferenceTest) {
+    auto url = Url{base + "/hello.html"};
+    auto status_code = 0;
+    auto future = cpr::HeadCallback([&status_code] (const Response& r) {
+                status_code = r.status_code;
+                return r.status_code;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackHeadTests, CallbackHeadLambdaTextReferenceTest) {
+    auto url = Url{base + "/hello.html"};
+    auto expected_text = std::string{};
+    auto future = cpr::HeadCallback([&expected_text] (const Response& r) {
+                expected_text = r.text;
+                return r.text;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackHeadTests, CallbackHeadFunctionStatusTest) {
+    auto url = Url{base + "/hello.html"};
+    auto status_code = 0;
+    auto callback = std::function<int(Response)>(std::bind(status_callback, std::ref(status_code),
+                                                           std::placeholders::_1));
+    auto future = cpr::HeadCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackHeadTests, CallbackHeadFunctionTextTest) {
+    auto url = Url{base + "/hello.html"};
+    auto expected_text = std::string{};
+    auto callback = std::function<std::string(Response)>(std::bind(text_callback,
+                                                                   std::ref(expected_text),
+                                                                   std::placeholders::_1));
+    auto future = cpr::HeadCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackHeadTests, CallbackHeadFunctionStatusReferenceTest) {
+    auto url = Url{base + "/hello.html"};
+    auto status_code = 0;
+    auto callback = std::function<int(Response)>(std::bind(status_callback_ref,
+                                                           std::ref(status_code),
+                                                           std::placeholders::_1));
+    auto future = cpr::HeadCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackHeadTests, CallbackHeadFunctionTextReferenceTest) {
+    auto url = Url{base + "/hello.html"};
+    auto expected_text = std::string{};
+    auto callback = std::function<std::string(Response)>(std::bind(text_callback_ref,
+                                                                   std::ref(expected_text),
+                                                                   std::placeholders::_1));
+    auto future = cpr::HeadCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackPostTests, CallbackPostLambdaStatusTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto status_code = 0;
+    auto future = cpr::PostCallback([&status_code] (Response r) {
+                status_code = r.status_code;
+                return r.status_code;
+            }, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackPostTests, CallbackPostLambdaTextTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto expected_text = std::string{};
+    auto future = cpr::PostCallback([&expected_text] (Response r) {
+                expected_text = r.text;
+                return r.text;
+            }, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackPostTests, CallbackPostLambdaStatusReferenceTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto status_code = 0;
+    auto future = cpr::PostCallback([&status_code] (const Response& r) {
+                status_code = r.status_code;
+                return r.status_code;
+            }, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackPostTests, CallbackPostLambdaTextReferenceTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto expected_text = std::string{};
+    auto future = cpr::PostCallback([&expected_text] (const Response& r) {
+                expected_text = r.text;
+                return r.text;
+            }, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackPostTests, CallbackPostFunctionStatusTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto status_code = 0;
+    auto callback = std::function<int(Response)>(std::bind(status_callback, std::ref(status_code),
+                                                           std::placeholders::_1));
+    auto future = cpr::PostCallback(callback, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackPostTests, CallbackPostFunctionTextTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto expected_text = std::string{};
+    auto callback = std::function<std::string(Response)>(std::bind(text_callback,
+                                                                   std::ref(expected_text),
+                                                                   std::placeholders::_1));
+    auto future = cpr::PostCallback(callback, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackPostTests, CallbackPostFunctionStatusReferenceTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto status_code = 0;
+    auto callback = std::function<int(Response)>(std::bind(status_callback_ref,
+                                                           std::ref(status_code),
+                                                           std::placeholders::_1));
+    auto future = cpr::PostCallback(callback, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackPostTests, CallbackPostFunctionTextReferenceTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto expected_text = std::string{};
+    auto callback = std::function<std::string(Response)>(std::bind(text_callback_ref,
+                                                                   std::ref(expected_text),
+                                                                   std::placeholders::_1));
+    auto future = cpr::PostCallback(callback, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackPutTests, CallbackPutLambdaStatusTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto status_code = 0;
+    auto future = cpr::PutCallback([&status_code] (Response r) {
+                status_code = r.status_code;
+                return r.status_code;
+            }, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackPutTests, CallbackPutLambdaTextTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto expected_text = std::string{};
+    auto future = cpr::PutCallback([&expected_text] (Response r) {
+                expected_text = r.text;
+                return r.text;
+            }, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackPutTests, CallbackPutLambdaStatusReferenceTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto status_code = 0;
+    auto future = cpr::PutCallback([&status_code] (const Response& r) {
+                status_code = r.status_code;
+                return r.status_code;
+            }, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackPutTests, CallbackPutLambdaTextReferenceTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto expected_text = std::string{};
+    auto future = cpr::PutCallback([&expected_text] (const Response& r) {
+                expected_text = r.text;
+                return r.text;
+            }, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackPutTests, CallbackPutFunctionStatusTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto status_code = 0;
+    auto callback = std::function<int(Response)>(std::bind(status_callback, std::ref(status_code),
+                                                           std::placeholders::_1));
+    auto future = cpr::PutCallback(callback, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackPutTests, CallbackPutFunctionTextTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto expected_text = std::string{};
+    auto callback = std::function<std::string(Response)>(std::bind(text_callback,
+                                                                   std::ref(expected_text),
+                                                                   std::placeholders::_1));
+    auto future = cpr::PutCallback(callback, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackPutTests, CallbackPutFunctionStatusReferenceTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto status_code = 0;
+    auto callback = std::function<int(Response)>(std::bind(status_callback_ref,
+                                                           std::ref(status_code),
+                                                           std::placeholders::_1));
+    auto future = cpr::PutCallback(callback, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackPutTests, CallbackPutFunctionTextReferenceTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto expected_text = std::string{};
+    auto callback = std::function<std::string(Response)>(std::bind(text_callback_ref,
+                                                                   std::ref(expected_text),
+                                                                   std::placeholders::_1));
+    auto future = cpr::PutCallback(callback, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackOptionsTests, CallbackOptionsLambdaStatusTest) {
+    auto url = Url{base + "/hello.html"};
+    auto status_code = 0;
+    auto future = cpr::OptionsCallback([&status_code] (Response r) {
+                status_code = r.status_code;
+                return r.status_code;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackOptionsTests, CallbackOptionsLambdaTextTest) {
+    auto url = Url{base + "/hello.html"};
+    auto expected_text = std::string{};
+    auto future = cpr::OptionsCallback([&expected_text] (Response r) {
+                expected_text = r.text;
+                return r.text;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackOptionsTests, CallbackOptionsLambdaStatusReferenceTest) {
+    auto url = Url{base + "/hello.html"};
+    auto status_code = 0;
+    auto future = cpr::OptionsCallback([&status_code] (const Response& r) {
+                status_code = r.status_code;
+                return r.status_code;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackOptionsTests, CallbackOptionsLambdaTextReferenceTest) {
+    auto url = Url{base + "/hello.html"};
+    auto expected_text = std::string{};
+    auto future = cpr::OptionsCallback([&expected_text] (const Response& r) {
+                expected_text = r.text;
+                return r.text;
+            }, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackOptionsTests, CallbackOptionsFunctionStatusTest) {
+    auto url = Url{base + "/hello.html"};
+    auto status_code = 0;
+    auto callback = std::function<int(Response)>(std::bind(status_callback, std::ref(status_code),
+                                                           std::placeholders::_1));
+    auto future = cpr::OptionsCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackOptionsTests, CallbackOptionsFunctionTextTest) {
+    auto url = Url{base + "/hello.html"};
+    auto expected_text = std::string{};
+    auto callback = std::function<std::string(Response)>(std::bind(text_callback,
+                                                                   std::ref(expected_text),
+                                                                   std::placeholders::_1));
+    auto future = cpr::OptionsCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackOptionsTests, CallbackOptionsFunctionStatusReferenceTest) {
+    auto url = Url{base + "/hello.html"};
+    auto status_code = 0;
+    auto callback = std::function<int(Response)>(std::bind(status_callback_ref,
+                                                           std::ref(status_code),
+                                                           std::placeholders::_1));
+    auto future = cpr::OptionsCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackOptionsTests, CallbackOptionsFunctionTextReferenceTest) {
+    auto url = Url{base + "/hello.html"};
+    auto expected_text = std::string{};
+    auto callback = std::function<std::string(Response)>(std::bind(text_callback_ref,
+                                                                   std::ref(expected_text),
+                                                                   std::placeholders::_1));
+    auto future = cpr::OptionsCallback(callback, url);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackPatchTests, CallbackPatchLambdaStatusTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto status_code = 0;
+    auto future = cpr::PatchCallback([&status_code] (Response r) {
+                status_code = r.status_code;
+                return r.status_code;
+            }, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackPatchTests, CallbackPatchLambdaTextTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto expected_text = std::string{};
+    auto future = cpr::PatchCallback([&expected_text] (Response r) {
+                expected_text = r.text;
+                return r.text;
+            }, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackPatchTests, CallbackPatchLambdaStatusReferenceTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto status_code = 0;
+    auto future = cpr::PatchCallback([&status_code] (const Response& r) {
+                status_code = r.status_code;
+                return r.status_code;
+            }, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackPatchTests, CallbackPatchLambdaTextReferenceTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto expected_text = std::string{};
+    auto future = cpr::PatchCallback([&expected_text] (const Response& r) {
+                expected_text = r.text;
+                return r.text;
+            }, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackPatchTests, CallbackPatchFunctionStatusTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto status_code = 0;
+    auto callback = std::function<int(Response)>(std::bind(status_callback, std::ref(status_code),
+                                                           std::placeholders::_1));
+    auto future = cpr::PatchCallback(callback, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackPatchTests, CallbackPatchFunctionTextTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto expected_text = std::string{};
+    auto callback = std::function<std::string(Response)>(std::bind(text_callback,
+                                                                   std::ref(expected_text),
+                                                                   std::placeholders::_1));
+    auto future = cpr::PatchCallback(callback, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+TEST(CallbackPatchTests, CallbackPatchFunctionStatusReferenceTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto status_code = 0;
+    auto callback = std::function<int(Response)>(std::bind(status_callback_ref,
+                                                           std::ref(status_code),
+                                                           std::placeholders::_1));
+    auto future = cpr::PatchCallback(callback, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(status_code, future.get());
+}
+
+TEST(CallbackPatchTests, CallbackPatchFunctionTextReferenceTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto expected_text = std::string{};
+    auto callback = std::function<std::string(Response)>(std::bind(text_callback_ref,
+                                                                   std::ref(expected_text),
+                                                                   std::placeholders::_1));
+    auto future = cpr::PatchCallback(callback, url, payload);
+    std::this_thread::sleep_for(sleep_time);
+    EXPECT_EQ(future.wait_for(zero), std::future_status::ready);
+    EXPECT_EQ(expected_text, future.get());
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    ::testing::AddGlobalTestEnvironment(server);
+    return RUN_ALL_TESTS();
+}
diff --git a/cpr/test/delete_tests.cpp b/cpr/test/delete_tests.cpp
new file mode 100644
index 0000000..906cea8
--- /dev/null
+++ b/cpr/test/delete_tests.cpp
@@ -0,0 +1,260 @@
+#include <gtest/gtest.h>
+
+#include <string>
+
+#include <cpr/cpr.h>
+
+#include "server.h"
+
+using namespace cpr;
+
+static Server* server = new Server();
+auto base = server->GetBaseUrl();
+
+TEST(DeleteTests, DeleteTest) {
+    auto url = Url{base + "/delete.html"};
+    auto response = cpr::Delete(url);
+    auto expected_text = std::string{"Delete success"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(DeleteTests, DeleteUnallowedTest) {
+    auto url = Url{base + "/delete_unallowed.html"};
+    auto response = cpr::Delete(url);
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(DeleteTests, DeleteJsonBodyTest) {
+    auto url = Url{base + "/delete.html"};
+    auto response = cpr::Delete(url, cpr::Body{"'foo': 'bar'"}, cpr::Header{{"Content-Type", "application/json"}});
+    auto expected_text = std::string{"'foo': 'bar'"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(DeleteTests, SessionDeleteTest) {
+    auto url = Url{base + "/delete.html"};
+    Session session;
+    session.SetUrl(url);
+    auto response = session.Delete();
+    auto expected_text = std::string{"Delete success"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(DeleteTests, SessionDeleteUnallowedTest) {
+    auto url = Url{base + "/delete_unallowed.html"};
+    Session session;
+    session.SetUrl(url);
+    auto response = session.Delete();
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(DeleteTests, SessionDeleteJsonBodyTest) {
+    auto url = Url{base + "/delete.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetHeader(cpr::Header{{"Content-Type", "application/json"}});
+    session.SetBody(cpr::Body{"{'foo': 'bar'}"});
+    auto response = session.Delete();
+    auto expected_text = std::string{"{'foo': 'bar'}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(DeleteTests, SessionDeleteAfterGetTest) {
+    Session session;
+    {
+        auto url = Url{base + "/get.html"};
+        session.SetUrl(url);
+        auto response = session.Get();
+    }
+    auto url = Url{base + "/delete.html"};
+    session.SetUrl(url);
+    auto response = session.Delete();
+    auto expected_text = std::string{"Delete success"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(DeleteTests, SessionDeleteUnallowedAfterGetTest) {
+    Session session;
+    {
+        auto url = Url{base + "/get.html"};
+        session.SetUrl(url);
+        auto response = session.Get();
+    }
+    auto url = Url{base + "/delete_unallowed.html"};
+    session.SetUrl(url);
+    auto response = session.Delete();
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(DeleteTests, SessionDeleteAfterHeadTest) {
+    Session session;
+    {
+        auto url = Url{base + "/get.html"};
+        session.SetUrl(url);
+        auto response = session.Head();
+    }
+    auto url = Url{base + "/delete.html"};
+    session.SetUrl(url);
+    auto response = session.Delete();
+    auto expected_text = std::string{"Delete success"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(DeleteTests, SessionDeleteUnallowedAfterHeadTest) {
+    Session session;
+    {
+        auto url = Url{base + "/get.html"};
+        session.SetUrl(url);
+        auto response = session.Head();
+    }
+    auto url = Url{base + "/delete_unallowed.html"};
+    session.SetUrl(url);
+    auto response = session.Delete();
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(DeleteTests, SessionDeleteAfterPostTest) {
+    Session session;
+    {
+        auto url = Url{base + "/url_post.html"};
+        auto payload = Payload{{"x", "5"}};
+        session.SetUrl(url);
+        auto response = session.Post();
+    }
+    auto url = Url{base + "/delete.html"};
+    session.SetUrl(url);
+    auto response = session.Delete();
+    auto expected_text = std::string{"Delete success"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(DeleteTests, SessionDeleteUnallowedAfterPostTest) {
+    Session session;
+    {
+        auto url = Url{base + "/url_post.html"};
+        auto payload = Payload{{"x", "5"}};
+        session.SetUrl(url);
+        auto response = session.Post();
+    }
+    auto url = Url{base + "/delete_unallowed.html"};
+    session.SetUrl(url);
+    auto response = session.Delete();
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(DeleteTests, AsyncDeleteTest) {
+    auto url = Url{base + "/delete.html"};
+    auto future_response = cpr::DeleteAsync(url);
+    auto response = future_response.get();
+    auto expected_text = std::string{"Delete success"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(DeleteTests, AsyncDeleteUnallowedTest) {
+    auto url = Url{base + "/delete_unallowed.html"};
+    auto future_response = cpr::DeleteAsync(url);
+    auto response = future_response.get();
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(DeleteTests, AsyncMultipleDeleteTest) {
+    auto url = Url{base + "/delete.html"};
+    std::vector<AsyncResponse> responses;
+    for (int i = 0; i < 10; ++i) {
+        responses.emplace_back(cpr::DeleteAsync(url));
+    }
+    for (auto& future_response : responses) {
+        auto response = future_response.get();
+        auto expected_text = std::string{"Delete success"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(DeleteTests, AsyncMultipleDeleteUnallowedTest) {
+    auto url = Url{base + "/delete_unallowed.html"};
+    std::vector<AsyncResponse> responses;
+    for (int i = 0; i < 10; ++i) {
+        responses.emplace_back(cpr::DeleteAsync(url));
+    }
+    for (auto& future_response : responses) {
+        auto response = future_response.get();
+        auto expected_text = std::string{"Method unallowed"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(405, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    ::testing::AddGlobalTestEnvironment(server);
+    return RUN_ALL_TESTS();
+}
diff --git a/cpr/test/error_tests.cpp b/cpr/test/error_tests.cpp
new file mode 100644
index 0000000..c3d3675
--- /dev/null
+++ b/cpr/test/error_tests.cpp
@@ -0,0 +1,96 @@
+#include <gtest/gtest.h>
+
+#include <chrono>
+#include <string>
+
+#include <cpr/cpr.h>
+#include <curl/curl.h>
+
+#include "server.h"
+
+using namespace cpr;
+
+static Server* server = new Server();
+auto base = server->GetBaseUrl();
+auto baseSSL = server->GetBaseUrlSSL();
+
+TEST(ErrorTests, BasicSSLFailure) {
+    auto url = Url{baseSSL + "/hello.html"};
+    auto response = cpr::Get(url);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(0, response.status_code);
+    auto curl_version = curl_version_info(CURLVERSION_NOW);
+    auto expected = ErrorCode::UNSUPPORTED_PROTOCOL;
+    if(curl_version->features & CURL_VERSION_SSL) {
+        expected = ErrorCode::SSL_CONNECT_ERROR;
+    }
+    EXPECT_EQ(expected, response.error.code);
+
+}
+
+TEST(ErrorTests, UnsupportedProtocolFailure) {
+    auto url = Url{"urk://wat.is.this"};
+    auto response = cpr::Get(url);
+    EXPECT_EQ(0, response.status_code);
+    EXPECT_EQ(ErrorCode::UNSUPPORTED_PROTOCOL, response.error.code);
+}
+
+TEST(ErrorTests, InvalidURLFailure) {
+    auto url = Url{"???"};
+    auto response = cpr::Get(url);
+    EXPECT_EQ(0, response.status_code);
+    EXPECT_EQ(ErrorCode::INVALID_URL_FORMAT, response.error.code);
+}
+
+TEST(ErrorTests, TimeoutFailure) {
+    auto url = Url{base + "/timeout.html"};
+    auto response = cpr::Get(url, cpr::Timeout{1});
+    EXPECT_EQ(0, response.status_code);
+    EXPECT_EQ(ErrorCode::OPERATION_TIMEDOUT, response.error.code);
+}
+
+TEST(ErrorTests, ChronoTimeoutFailure) {
+    auto url = Url{base + "/timeout.html"};
+    auto response = cpr::Get(url, cpr::Timeout{std::chrono::milliseconds{1}});
+    EXPECT_EQ(0, response.status_code);
+    EXPECT_EQ(ErrorCode::OPERATION_TIMEDOUT, response.error.code);
+}
+
+TEST(ErrorTests, LowSpeedTimeFailure) {
+    auto url = Url{base + "/low_speed.html"};
+    auto response = cpr::Get(url, cpr::LowSpeed{1000, 1});
+    EXPECT_EQ(0, response.status_code);
+    EXPECT_EQ(ErrorCode::OPERATION_TIMEDOUT, response.error.code);
+}
+
+TEST(ErrorTests, LowSpeedBytesFailure) {
+    auto url = Url{base + "/low_speed_bytes.html"};
+    auto response = cpr::Get(url, cpr::LowSpeed{1000, 1});
+    EXPECT_EQ(0, response.status_code);
+    EXPECT_EQ(ErrorCode::OPERATION_TIMEDOUT, response.error.code);
+}
+
+TEST(ErrorTests, ProxyFailure) {
+    auto url = Url{base + "/hello.html"};
+    auto response = cpr::Get(url, cpr::Proxies{{"http", "http://bad_host/"}});
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(0, response.status_code);
+    EXPECT_EQ(ErrorCode::PROXY_RESOLUTION_FAILURE, response.error.code);
+}
+
+TEST(ErrorTests, BoolFalseTest) {
+    Error error;
+    EXPECT_FALSE(error);
+}
+
+TEST(ErrorTests, BoolTrueTest) {
+    Error error;
+    error.code = ErrorCode::UNSUPPORTED_PROTOCOL;
+    EXPECT_TRUE(error);
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    ::testing::AddGlobalTestEnvironment(server);
+    return RUN_ALL_TESTS();
+}
diff --git a/cpr/test/get_tests.cpp b/cpr/test/get_tests.cpp
new file mode 100644
index 0000000..a3ef292
--- /dev/null
+++ b/cpr/test/get_tests.cpp
@@ -0,0 +1,1178 @@
+#include <gtest/gtest.h>
+
+#include <string>
+
+#include <cpr/cpr.h>
+
+#include "server.h"
+
+using namespace cpr;
+
+static Server* server = new Server();
+auto base = server->GetBaseUrl();
+
+TEST(BasicTests, HelloWorldTest) {
+    auto url = Url{base + "/hello.html"};
+    auto response = cpr::Get(url);
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicTests, TimeoutTest) {
+    auto url = Url{base + "/hello.html"};
+    auto response = cpr::Get(url, Timeout{0L});
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicTests, BasicJsonTest) {
+    auto url = Url{base + "/basic.json"};
+    auto response = cpr::Get(url);
+    auto expected_text = std::string{"[\n"
+                                     "  {\n"
+                                     "    \"first_key\": \"first_value\",\n"
+                                     "    \"second_key\": \"second_value\"\n"
+                                     "  }\n"
+                                     "]"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/octet-stream"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicTests, ResourceNotFoundTest) {
+    auto url = Url{base + "/error.html"};
+    auto response = cpr::Get(url);
+    auto expected_text = std::string{"404 Not Found\n"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/plain"}, response.header["content-type"]);
+    EXPECT_EQ(404, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicTests, BadHostTest) {
+    auto url = Url{"http://bad_host/"};
+    auto response = cpr::Get(url);
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(0, response.status_code);
+    EXPECT_EQ(ErrorCode::HOST_RESOLUTION_FAILURE, response.error.code);
+}
+
+TEST(BasicTests, RequestBodyTest) {
+    auto url = Url{base + "/body_get.html"};
+    auto body = Body{"message=abc123"};
+    auto response = cpr::Get(url, body);
+    auto expected_text = std::string{"abc123"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(CookiesTests, SingleCookieTest) {
+    auto url = Url{base + "/basic_cookies.html"};
+    auto cookies = Cookies{{"hello", "world"}, {"my", "another; fake=cookie;"}};
+    auto response = cpr::Get(url, cookies);
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+    cookies = response.cookies;
+    EXPECT_EQ(cookies["cookie"], response.cookies["cookie"]);
+    EXPECT_EQ(cookies["icecream"], response.cookies["icecream"]);
+    EXPECT_EQ(cookies["expires"], response.cookies["expires"]);
+}
+
+TEST(CookiesTests, CheckBasicCookieTest) {
+    // server validates whether the cookies are indeed present
+    auto url = Url{base + "/check_cookies.html"};
+    auto cookies = Cookies{{"cookie", "chocolate"}, {"icecream", "vanilla"}};
+    auto response = cpr::Get(url, cookies);
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(CookiesTests, V1CookieTest) {
+    auto url = Url{base + "/v1_cookies.html"};
+    auto response = cpr::Get(url);
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+    auto cookies = response.cookies;
+    EXPECT_EQ("\"value with spaces (v1 cookie)\"", cookies["cookie"]);
+}
+
+TEST(CookiesTests, CheckV1CookieTest) {
+    // server validates whether the cookie is indeed present
+    auto url = Url{base + "/check_v1_cookies.html"};
+    auto cookies = Cookies{{"cookie", "\"value with spaces (v1 cookie)\""}};
+    auto response = cpr::Get(url, cookies);
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ParameterTests, SingleParameterTest) {
+    auto url = Url{base + "/hello.html"};
+    auto parameters = Parameters{{"key", "value"}};
+    auto response = cpr::Get(url, parameters);
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?key=value"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ParameterTests, SingleParameterOnlyKeyTest) {
+    auto url = Url{base + "/hello.html"};
+    auto parameters = Parameters{{"key", ""}};
+    auto response = cpr::Get(url, parameters);
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?key"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+}
+
+TEST(ParameterTests, MultipleParametersTest) {
+    auto url = Url{base + "/hello.html"};
+    auto response = cpr::Get(url, Parameters{{"key", "value"},
+                                             {"hello", "world"},
+                                             {"test", "case"}});
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?key=value&hello=world&test=case"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ParameterTests, MultipleDynamicParametersTest) {
+    auto url = Url{base + "/hello.html"};
+    auto parameters = Parameters{{"key", "value"}};
+    parameters.AddParameter({"hello", "world"});
+    parameters.AddParameter({"test", "case"});
+    auto response = cpr::Get(url, parameters);
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?key=value&hello=world&test=case"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationTests, BasicAuthenticationSuccessTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "password"});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationTests, BasicDigestSuccessTest) {
+    auto url = Url{base + "/digest_auth.html"};
+    auto response = cpr::Get(url, Digest{"user", "password"});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAthenticationParameterTests, BasicAuthenticationSuccessSingleParameterTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "password"},
+                             Parameters{{"hello", "world"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?hello=world"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterTests, BasicAuthenticationSuccessMultipleParametersTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "password"},
+                             Parameters{{"key", "value"}, {"hello", "world"}, {"test", "case"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?key=value&hello=world&test=case"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterTests, BasicAuthenticationSuccessSingleParameterReverseTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{{"hello", "world"}},
+                             Authentication{"user", "password"});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?hello=world"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterTests, BasicAuthenticationSuccessMultipleParametersReverseTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{{"key", "value"},
+                                             {"hello", "world"},
+                                             {"test", "case"}},
+                             Authentication{"user", "password"});
+
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?key=value&hello=world&test=case"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationHeaderTests, BasicAuthenticationSuccessSingleHeaderTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "password"},
+                             Header{{"hello", "world"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationHeaderTests, BasicAuthenticationSuccessMultipleHeadersTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "password"},
+                             Header{{"key", "value"}, {"hello", "world"}, {"test", "case"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(std::string{"value"}, response.header["key"]);
+    EXPECT_EQ(std::string{"case"}, response.header["test"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationHeaderTests, BasicAuthenticationSuccessSingleHeaderReverseTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Header{{"hello", "world"}},
+                             Authentication{"user", "password"});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationHeaderTests, BasicAuthenticationSuccessMultipleHeadersReverseTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Header{{"key", "value"}, {"hello", "world"}, {"test", "case"}},
+                             Authentication{"user", "password"});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(std::string{"value"}, response.header["key"]);
+    EXPECT_EQ(std::string{"case"}, response.header["test"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationTests, BasicAuthenticationNullFailureTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url);
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationTests, BasicAuthenticationFailureTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "bad_password"});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterTests, BasicAuthenticationFailureSingleParameterTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "bad_password"},
+                             Parameters{{"hello", "world"}});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{url + "?hello=world"}, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterTests, BasicAuthenticationFailureMultipleParametersTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "bad_password"},
+                             Parameters{{"key", "value"}, {"hello", "world"}, {"test", "case"}});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{url + "?key=value&hello=world&test=case"}, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeaderTests, HeaderJsonTest) {
+    auto url = Url{base + "/basic.json"};
+    auto response = cpr::Get(url, Header{{"content-type", "application/json"}});
+    auto expected_text = std::string{"[\n"
+                                     "  {\n"
+                                     "    \"first_key\": \"first_value\",\n"
+                                     "    \"second_key\": \"second_value\"\n"
+                                     "  }\n"
+                                     "]"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeaderTests, HeaderReflectNoneTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Get(url);
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeaderTests, HeaderReflectEmptyTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Get(url, Header{});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeaderTests, HeaderReflectSingleTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Get(url, Header{{"hello", "world"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeaderTests, HeaderReflectMultipleTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Get(url, Header{{"hello", "world"}, {"key", "value"}, {"test", "case"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(std::string{"value"}, response.header["key"]);
+    EXPECT_EQ(std::string{"case"}, response.header["test"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeaderTests, HeaderReflectCaseInsensitiveTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Get(url, Header{{"HeLlO", "wOrLd"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"wOrLd"}, response.header["hello"]);
+    EXPECT_EQ(std::string{"wOrLd"}, response.header["HELLO"]);
+    EXPECT_EQ(std::string{"wOrLd"}, response.header["hElLo"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeaderTests, SetEmptyHeaderTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Get(url, Header{{"hello", ""}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ParameterHeaderTests, HeaderReflectNoneParametersTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Get(url, Parameters{{"one", "two"}, {"three", "four"}, {"five", "six"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two&three=four&five=six"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ParameterHeaderTests, HeaderReflectEmptyParametersTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Get(url, Header{},
+                             Parameters{{"one", "two"}, {"three", "four"}, {"five", "six"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two&three=four&five=six"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ParameterHeaderTests, HeaderReflectSingleParametersTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Get(url, Header{{"hello", "world"}},
+                             Parameters{{"one", "two"}, {"three", "four"}, {"five", "six"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two&three=four&five=six"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ParameterHeaderTests, HeaderReflectMultipleParametersTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Get(url, Header{{"hello", "world"}, {"key", "value"}, {"test", "case"}},
+                             Parameters{{"one", "two"}, {"three", "four"}, {"five", "six"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two&three=four&five=six"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(std::string{"value"}, response.header["key"]);
+    EXPECT_EQ(std::string{"case"}, response.header["test"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ParameterHeaderTests, HeaderReflectCaseInsensitiveParametersTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Get(url, Header{{"HeLlO", "wOrLd"}},
+                             Parameters{{"one", "two"}, {"three", "four"}, {"five", "six"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two&three=four&five=six"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"wOrLd"}, response.header["hello"]);
+    EXPECT_EQ(std::string{"wOrLd"}, response.header["HELLO"]);
+    EXPECT_EQ(std::string{"wOrLd"}, response.header["hElLo"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ParameterHeaderTests, HeaderReflectEmptyParametersReverseTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Get(url, Parameters{{"one", "two"}, {"three", "four"}, {"five", "six"}},
+                             Header{});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two&three=four&five=six"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ParameterHeaderTests, HeaderReflectSingleParametersReverseTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Get(url, Parameters{{"one", "two"}, {"three", "four"}, {"five", "six"}},
+                             Header{{"hello", "world"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two&three=four&five=six"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ParameterHeaderTests, HeaderReflectMultipleParametersReverseTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Get(url, Parameters{{"one", "two"}, {"three", "four"}, {"five", "six"}},
+                             Header{{"hello", "world"}, {"key", "value"}, {"test", "case"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two&three=four&five=six"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(std::string{"value"}, response.header["key"]);
+    EXPECT_EQ(std::string{"case"}, response.header["test"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ParameterHeaderTests, HeaderReflectCaseInsensitiveParametersReverseTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Get(url, Parameters{{"one", "two"}, {"three", "four"}, {"five", "six"}},
+                             Header{{"HeLlO", "wOrLd"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two&three=four&five=six"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"wOrLd"}, response.header["hello"]);
+    EXPECT_EQ(std::string{"wOrLd"}, response.header["HELLO"]);
+    EXPECT_EQ(std::string{"wOrLd"}, response.header["hElLo"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderAATest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "password"}, Parameters{}, Header{});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderABTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "bad_password"}, Parameters{}, Header{});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderACTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "password"}, Parameters{{"one", "two"}},
+                             Header{});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderADTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "bad_password"},
+                             Parameters{{"one", "two"}}, Header{});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderAETest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "password"}, Parameters{},
+                             Header{{"hello", "world"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderAFTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "bad_password"}, Parameters{},
+                             Header{{"hello", "world"}});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderAGTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "password"}, Parameters{{"one", "two"}},
+                             Header{{"hello", "world"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderAHTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "bad_password"},
+                             Parameters{{"one", "two"}}, Header{{"hello", "world"}});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderBATest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{}, Header{}, Authentication{"user", "password"});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderBBTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{}, Header{}, Authentication{"user", "bad_password"});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderBCTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{{"one", "two"}}, Header{},
+                             Authentication{"user", "password"});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderBDTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{{"one", "two"}}, Header{},
+                             Authentication{"user", "bad_password"});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderBETest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{}, Header{{"hello", "world"}},
+                             Authentication{"user", "password"});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderBFTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{}, Header{{"hello", "world"}},
+                             Authentication{"user", "bad_password"});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderBGTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{{"one", "two"}}, Header{{"hello", "world"}},
+                             Authentication{"user", "password"});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderBHTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{{"one", "two"}}, Header{{"hello", "world"}},
+                             Authentication{"user", "bad_password"});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderCATest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Header{}, Authentication{"user", "password"}, Parameters{});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderCBTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Header{}, Authentication{"user", "bad_password"}, Parameters{});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderCCTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url,  Header{}, Authentication{"user", "password"},
+                             Parameters{{"one", "two"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderCDTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url,  Header{}, Authentication{"user", "bad_password"},
+                             Parameters{{"one", "two"}});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderCETest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Header{{"hello", "world"}}, Authentication{"user", "password"},
+                             Parameters{});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderCFTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Header{{"hello", "world"}},
+                             Authentication{"user", "bad_password"}, Parameters{});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderCGTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url,  Header{{"hello", "world"}}, Authentication{"user", "password"},
+                             Parameters{{"one", "two"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderCHTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url,  Header{{"hello", "world"}},
+                             Authentication{"user", "bad_password"}, Parameters{{"one", "two"}});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderDATest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "password"}, Header{}, Parameters{});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderDBTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "bad_password"}, Header{}, Parameters{});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderDCTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "password"}, Header{},
+                             Parameters{{"one", "two"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderDDTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "bad_password"}, Header{},
+                             Parameters{{"one", "two"}});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderDETest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "password"}, Header{{"hello", "world"}},
+                             Parameters{});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderDFTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "bad_password"},
+                             Header{{"hello", "world"}}, Parameters{});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderDGTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "password"}, Header{{"hello", "world"}},
+                             Parameters{{"one", "two"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderDHTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Authentication{"user", "bad_password"},
+                             Header{{"hello", "world"}}, Parameters{{"one", "two"}});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderEATest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Header{}, Parameters{}, Authentication{"user", "password"});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderEBTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Header{}, Parameters{}, Authentication{"user", "bad_password"});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderECTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Header{}, Parameters{{"one", "two"}}, Authentication{"user", "password"});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderEDTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Header{}, Parameters{{"one", "two"}}, Authentication{"user", "bad_password"});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderEETest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Header{{"hello", "world"}}, Parameters{}, Authentication{"user", "password"});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderEFTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Header{{"hello", "world"}}, Parameters{}, Authentication{"user", "bad_password"});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderEGTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Header{{"hello", "world"}}, Parameters{{"one", "two"}}, Authentication{"user", "password"});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderEHTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Header{{"hello", "world"}}, Parameters{{"one", "two"}}, Authentication{"user", "bad_password"});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderFATest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{}, Authentication{"user", "password"}, Header{});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderFBTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{}, Authentication{"user", "bad_password"}, Header{});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderFCTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{{"one", "two"}}, Authentication{"user", "password"}, Header{});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderFDTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{{"one", "two"}}, Authentication{"user", "bad_password"}, Header{});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderFETest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{}, Authentication{"user", "password"}, Header{{"hello", "world"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderFFTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{}, Authentication{"user", "bad_password"}, Header{{"hello", "world"}});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderFGTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{{"one", "two"}}, Authentication{"user", "password"}, Header{{"hello", "world"}});
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BasicAuthenticationParameterHeaderTests, BasicAuthenticationParameterHeaderFHTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Get(url, Parameters{{"one", "two"}}, Authentication{"user", "bad_password"}, Header{{"hello", "world"}});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{url + "?one=two"}, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(GetRedirectTests, RedirectTest) {
+    auto url = Url{base + "/temporary_redirect.html"};
+    auto response = cpr::Get(url, false); // This should be turned into an object
+    auto expected_text = std::string{"Found"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(302, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(GetRedirectTests, ZeroMaxRedirectsTest) {
+    auto url = Url{base + "/hello.html"};
+    auto response = cpr::Get(url, MaxRedirects(0));
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    ::testing::AddGlobalTestEnvironment(server);
+    return RUN_ALL_TESTS();
+}
diff --git a/cpr/test/head_tests.cpp b/cpr/test/head_tests.cpp
new file mode 100644
index 0000000..d222ee8
--- /dev/null
+++ b/cpr/test/head_tests.cpp
@@ -0,0 +1,203 @@
+#include <gtest/gtest.h>
+
+#include <string>
+
+#include <cpr/cpr.h>
+
+#include "server.h"
+
+using namespace cpr;
+
+static Server* server = new Server();
+auto base = server->GetBaseUrl();
+
+TEST(HeadTests, BasicHeadTest) {
+    auto url = Url{base + "/hello.html"};
+    auto response = cpr::Head(url);
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeadTests, ComplexHeadTest) {
+    auto url = Url{base + "/basic.json"};
+    auto response = cpr::Head(url);
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/octet-stream"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeadTests, ResourceNotFoundHeadTest) {
+    auto url = Url{base + "/error.html"};
+    auto response = cpr::Head(url);
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/plain"}, response.header["content-type"]);
+    EXPECT_EQ(404, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeadTests, BadHostHeadTest) {
+    auto url = Url{"http://bad_host/"};
+    auto response = cpr::Head(url);
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(0, response.status_code);
+    EXPECT_EQ(ErrorCode::HOST_RESOLUTION_FAILURE, response.error.code);
+}
+
+TEST(HeadTests, CookieHeadTest) {
+    auto url = Url{base + "/basic_cookies.html"};
+    auto cookies = Cookies{{"hello", "world"}, {"my", "another; fake=cookie;"}};
+    auto response = cpr::Head(url, cookies);
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+    cookies = response.cookies;
+    EXPECT_EQ(cookies["cookie"], response.cookies["cookie"]);
+    EXPECT_EQ(cookies["icecream"], response.cookies["icecream"]);
+    EXPECT_EQ(cookies["expires"], response.cookies["expires"]);
+}
+
+TEST(HeadTests, ParameterHeadTest) {
+    auto url = Url{base + "/hello.html"};
+    auto parameters = Parameters{{"key", "value"}};
+    auto response = cpr::Head(url, parameters);
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{url + "?key=value"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeadTests, AuthenticationSuccessHeadTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Head(url, Authentication{"user", "password"});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeadTests, AuthenticationNullFailureHeadTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Head(url);
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeadTests, AuthenticationFailureHeadTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    auto response = cpr::Head(url, Authentication{"user", "bad_password"});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(401, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeadTests, DISABLED_DigestSuccessHeadTest) { // Is nondeterministic using embedded mongoose
+    auto url = Url{base + "/digest_auth.html"};
+    auto response = cpr::Head(url, Digest{"user", "password"});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeadTests, HeaderReflectNoneHeadTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Head(url);
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeadTests, HeaderReflectEmptyHeadTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Head(url, Header{});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeadTests, HeaderReflectHeadTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Head(url, Header{{"hello", "world"}});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeadTests, SetEmptyHeaderHeadTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Head(url, Header{{"hello", ""}});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(std::string{}, response.header["hello"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeadTests, RedirectHeadTest) {
+    auto url = Url{base + "/temporary_redirect.html"};
+    auto response = cpr::Head(url, false);
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(302, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeadTests, ZeroMaxRedirectsHeadTest) {
+    auto url = Url{base + "/hello.html"};
+    auto response = cpr::Head(url, 0L);
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(HeadTests, BasicHeadAsyncTest) {
+    auto url = Url{base + "/hello.html"};
+    std::vector<AsyncResponse> responses;
+    for (int i = 0; i < 10; ++i) {
+        responses.emplace_back(cpr::HeadAsync(url));
+    }
+    for (auto& future_response : responses) {
+        auto response = future_response.get();
+        EXPECT_EQ(std::string{}, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    ::testing::AddGlobalTestEnvironment(server);
+    return RUN_ALL_TESTS();
+}
diff --git a/cpr/test/options_tests.cpp b/cpr/test/options_tests.cpp
new file mode 100644
index 0000000..f927ecd
--- /dev/null
+++ b/cpr/test/options_tests.cpp
@@ -0,0 +1,78 @@
+#include <gtest/gtest.h>
+
+#include <string>
+
+#include <cpr/cpr.h>
+
+#include "server.h"
+
+using namespace cpr;
+
+static Server* server = new Server();
+auto base = server->GetBaseUrl();
+
+TEST(OptionsTests, BaseUrlTest) {
+    auto url = Url{base + "/"};
+    auto response = cpr::Options(url);
+    auto expected_text = std::string{""};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"GET, POST, PUT, DELETE, PATCH, OPTIONS"},
+              response.header["Access-Control-Allow-Methods"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(OptionsTests, SpecificUrlTest) {
+    auto url = Url{base + "/hello.html"};
+    auto response = cpr::Options(url);
+    auto expected_text = std::string{""};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"GET, OPTIONS"},
+              response.header["Access-Control-Allow-Methods"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(OptionsTests, AsyncBaseUrlTest) {
+    auto url = Url{base + "/"};
+    std::vector<AsyncResponse> responses;
+    for (int i = 0; i < 10; ++i) {
+        responses.emplace_back(cpr::OptionsAsync(url));
+    }
+    for (auto& future_response : responses) {
+        auto response = future_response.get();
+        auto expected_text = std::string{""};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"GET, POST, PUT, DELETE, PATCH, OPTIONS"},
+                  response.header["Access-Control-Allow-Methods"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(OptionsTests, AsyncSpecificUrlTest) {
+    auto url = Url{base + "/hello.html"};
+    std::vector<AsyncResponse> responses;
+    for (int i = 0; i < 10; ++i) {
+        responses.emplace_back(cpr::OptionsAsync(url));
+    }
+    for (auto& future_response : responses) {
+        auto response = future_response.get();
+        auto expected_text = std::string{""};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"GET, OPTIONS"},
+                  response.header["Access-Control-Allow-Methods"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    ::testing::AddGlobalTestEnvironment(server);
+    return RUN_ALL_TESTS();
+}
diff --git a/cpr/test/patch_tests.cpp b/cpr/test/patch_tests.cpp
new file mode 100644
index 0000000..5310114
--- /dev/null
+++ b/cpr/test/patch_tests.cpp
@@ -0,0 +1,270 @@
+#include <gtest/gtest.h>
+
+#include <string>
+
+#include <cpr/cpr.h>
+
+#include "server.h"
+
+using namespace cpr;
+
+static Server* server = new Server();
+auto base = server->GetBaseUrl();
+
+TEST(PatchTests, PatchTest) {
+    auto url = Url{base + "/patch.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto response = cpr::Patch(url, payload);
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PatchTests, PatchUnallowedTest) {
+    auto url = Url{base + "/patch_unallowed.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto response = cpr::Patch(url, payload);
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PatchTests, SessionPatchTest) {
+    auto url = Url{base + "/patch.html"};
+    auto payload = Payload{{"x", "5"}};
+    Session session;
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Patch();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PatchTests, SessionPatchUnallowedTest) {
+    auto url = Url{base + "/patch_unallowed.html"};
+    auto payload = Payload{{"x", "5"}};
+    Session session;
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Patch();
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PatchTests, SessionPatchAfterGetTest) {
+    Session session;
+    {
+        auto url = Url{base + "/get.html"};
+        session.SetUrl(url);
+        auto response = session.Get();
+    }
+    auto url = Url{base + "/patch.html"};
+    auto payload = Payload{{"x", "5"}};
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Patch();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PatchTests, SessionPatchUnallowedAfterGetTest) {
+    Session session;
+    {
+        auto url = Url{base + "/get.html"};
+        session.SetUrl(url);
+        auto response = session.Get();
+    }
+    auto url = Url{base + "/patch_unallowed.html"};
+    auto payload = Payload{{"x", "5"}};
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Patch();
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PatchTests, SessionPatchAfterHeadTest) {
+    Session session;
+    {
+        auto url = Url{base + "/get.html"};
+        session.SetUrl(url);
+        auto response = session.Head();
+    }
+    auto url = Url{base + "/patch.html"};
+    auto payload = Payload{{"x", "5"}};
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Patch();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PatchTests, SessionPatchUnallowedAfterHeadTest) {
+    Session session;
+    {
+        auto url = Url{base + "/get.html"};
+        session.SetUrl(url);
+        auto response = session.Head();
+    }
+    auto url = Url{base + "/patch_unallowed.html"};
+    auto payload = Payload{{"x", "5"}};
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Patch();
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PatchTests, SessionPatchAfterPostTest) {
+    Session session;
+    {
+        auto url = Url{base + "/url_post.html"};
+        auto payload = Payload{{"x", "5"}};
+        session.SetUrl(url);
+        auto response = session.Post();
+    }
+    auto url = Url{base + "/patch.html"};
+    auto payload = Payload{{"x", "5"}};
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Patch();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PatchTests, SessionPatchUnallowedAfterPostTest) {
+    Session session;
+    {
+        auto url = Url{base + "/url_post.html"};
+        auto payload = Payload{{"x", "5"}};
+        session.SetUrl(url);
+        auto response = session.Post();
+    }
+    auto url = Url{base + "/patch_unallowed.html"};
+    auto payload = Payload{{"x", "5"}};
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Patch();
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PatchTests, AsyncPatchTest) {
+    auto url = Url{base + "/patch.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto future_response = cpr::PatchAsync(url, payload);
+    auto response = future_response.get();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PatchTests, AsyncPatchUnallowedTest) {
+    auto url = Url{base + "/patch_unallowed.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto future_response = cpr::PatchAsync(url, payload);
+    auto response = future_response.get();
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PatchTests, AsyncMultiplePatchTest) {
+    auto url = Url{base + "/patch.html"};
+    auto payload = Payload{{"x", "5"}};
+    std::vector<AsyncResponse> responses;
+    for (int i = 0; i < 10; ++i) {
+        responses.emplace_back(cpr::PatchAsync(url, payload));
+    }
+    for (auto& future_response : responses) {
+        auto response = future_response.get();
+        auto expected_text = std::string{"{\n"
+                                         "  \"x\": 5\n"
+                                         "}"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(PatchTests, AsyncMultiplePatchUnallowedTest) {
+    auto url = Url{base + "/patch_unallowed.html"};
+    auto payload = Payload{{"x", "5"}};
+    std::vector<AsyncResponse> responses;
+    for (int i = 0; i < 10; ++i) {
+        responses.emplace_back(cpr::PatchAsync(url, payload));
+    }
+    for (auto& future_response : responses) {
+        auto response = future_response.get();
+        auto expected_text = std::string{"Method unallowed"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(405, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    ::testing::AddGlobalTestEnvironment(server);
+    return RUN_ALL_TESTS();
+}
diff --git a/cpr/test/post_tests.cpp b/cpr/test/post_tests.cpp
new file mode 100644
index 0000000..362186f
--- /dev/null
+++ b/cpr/test/post_tests.cpp
@@ -0,0 +1,365 @@
+#include <gtest/gtest.h>
+
+#include <array>
+#include <cstdio>
+#include <fstream>
+#include <string>
+
+#include <cpr/cpr.h>
+#include <cpr/multipart.h>
+
+#include "server.h"
+
+using namespace cpr;
+
+static Server* server = new Server();
+auto base = server->GetBaseUrl();
+
+TEST(UrlEncodedPostTests, UrlPostSingleTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto response = cpr::Post(url, Payload{{"x", "5"}});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, UrlPostAddPayloadPair) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "1"}};
+    payload.AddPair({"y", "2"});
+    auto response = cpr::Post(url, payload);
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 1,\n"
+                                     "  \"y\": 2,\n"
+                                     "  \"sum\": 3\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+}
+
+TEST(UrlEncodedPostTests, UrlPostPayloadIteratorTest) {
+    auto url = Url{base + "/url_post.html"};
+    std::vector<Pair> payloadData;
+    payloadData.push_back({"x", "1"});
+    payloadData.push_back({"y", "2"});
+    auto response = cpr::Post(url, Payload(payloadData.begin(), payloadData.end()));
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 1,\n"
+                                     "  \"y\": 2,\n"
+                                     "  \"sum\": 3\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+}
+
+TEST(UrlEncodedPostTests, UrlPostEncodeTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto response = cpr::Post(url, Payload{{"x", "hello world!!~"}});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": hello world!!~\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, UrlPostEncodeNoCopyTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "hello world!!~"}};
+    // payload lives through the lifetime of Post, so it doesn't need to be copied
+    auto response = cpr::Post(url, payload);
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": hello world!!~\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, UrlPostManyTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto response = cpr::Post(url, Payload{{"x", 5}, {"y", 13}});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5,\n"
+                                     "  \"y\": 13,\n"
+                                     "  \"sum\": 18\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, UrlPostBadHostTest) {
+    auto url = Url{"http://bad_host/"};
+    auto response = cpr::Post(url, Payload{{"hello", "world"}});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(0, response.status_code);
+    EXPECT_EQ(ErrorCode::HOST_RESOLUTION_FAILURE, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, FormPostSingleTest) {
+    auto url = Url{base + "/form_post.html"};
+    auto response = cpr::Post(url, Multipart{{"x", 5}});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, FormPostFileTest) {
+    auto filename = std::string{"test_file"};
+    auto content = std::string{"hello world"};
+    std::ofstream test_file;
+    test_file.open(filename);
+    test_file << content;
+    test_file.close();
+    auto url = Url{base + "/form_post.html"};
+    auto response = cpr::Post(url, Multipart{{"x", File{filename}}});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": " + content + "\n"
+                                     "}"};
+    std::remove(filename.data());
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, FormPostFileNoCopyTest) {
+    auto filename = std::string{"test_file"};
+    auto content = std::string{"hello world"};
+    std::ofstream test_file;
+    test_file.open(filename);
+    test_file << content;
+    test_file.close();
+    auto url = Url{base + "/form_post.html"};
+    auto multipart = Multipart{{"x", File{filename}}};
+    auto response = cpr::Post(url, multipart);
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": " + content + "\n"
+                                     "}"};
+    std::remove(filename.data());
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, FormPostFileBufferTest) {
+    auto content = std::string{"hello world"};
+    auto url = Url{base + "/form_post.html"};
+    auto response = cpr::Post(url, Multipart{{"x", Buffer{content.begin(), content.end(), "test_file"}}});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": " + content + "\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, FormPostFileBufferNoCopyTest) {
+    auto content = std::string{"hello world"};
+    auto url = Url{base + "/form_post.html"};
+    auto multipart = Multipart{{"x", Buffer{content.begin(), content.end(), "test_file"}}};
+    auto response = cpr::Post(url, multipart);
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": " + content + "\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, FormPostFileBufferPointerTest) {
+    const char *content = "hello world";
+    auto url = Url{base + "/form_post.html"};
+    auto response = cpr::Post(url, Multipart{{"x", Buffer{content, 11 + content, "test_file"}}});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": " + std::string(content) + "\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, FormPostFileBufferArrayTest) {
+    const char content[] = "hello world";
+    auto url = Url{base + "/form_post.html"};
+    // We subtract 1 from std::end() because we don't want to include the terminating null
+    auto response = cpr::Post(
+            url, Multipart{{"x", Buffer{std::begin(content), std::end(content) - 1, "test_file"}}});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": " + std::string(content) + "\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, FormPostFileBufferVectorTest) {
+    std::vector<unsigned char> content{'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'};
+    auto url = Url{base + "/form_post.html"};
+    auto response =
+            cpr::Post(url, Multipart{{"x", Buffer{content.begin(), content.end(), "test_file"}}});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": hello world\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, FormPostFileBufferStdArrayTest) {
+    std::array<unsigned char, 11> content{{'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'}};
+    auto url = Url{base + "/form_post.html"};
+    auto response =
+            cpr::Post(url, Multipart{{"x", Buffer{content.begin(), content.end(), "test_file"}}});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": hello world\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, FormPostManyTest) {
+    auto url = Url{base + "/form_post.html"};
+    auto response = cpr::Post(url, Multipart{{"x", 5}, {"y", 13}});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5,\n"
+                                     "  \"y\": 13,\n"
+                                     "  \"sum\": 18\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, FormPostManyNoCopyTest) {
+    auto url = Url{base + "/form_post.html"};
+    auto multipart = Multipart{{"x", 5}, {"y", 13}};
+    auto response = cpr::Post(url, multipart);
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5,\n"
+                                     "  \"y\": 13,\n"
+                                     "  \"sum\": 18\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, FormPostContentTypeTest) {
+    auto url = Url{base + "/form_post.html"};
+    auto response = cpr::Post(url, Multipart{{"x", 5, "application/number"}});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, FormPostContentTypeLValueTest) {
+    auto url = Url{base + "/form_post.html"};
+    auto multipart = Multipart{{"x", 5, "application/number"}};
+    auto response = cpr::Post(url, multipart);
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, UrlPostAsyncSingleTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto payload = Payload{{"x", "5"}};
+    std::vector<AsyncResponse> responses;
+    for (int i = 0; i < 10; ++i) {
+        responses.emplace_back(cpr::PostAsync(url, payload));
+    }
+    for (auto& future_response : responses) {
+        auto response = future_response.get();
+        auto expected_text = std::string{"{\n"
+                                         "  \"x\": 5\n"
+                                         "}"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+        EXPECT_EQ(201, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(UrlEncodedPostTests, UrlReflectTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    auto response = cpr::Post(url, Payload{{"x", "5"}});
+    auto expected_text = std::string{"Header reflect POST"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(UrlEncodedPostTests, PostWithNoBodyTest) {
+    auto url = Url{base + "/form_post.html"};
+    auto response = cpr::Post(url);
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": \n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    ::testing::AddGlobalTestEnvironment(server);
+    return RUN_ALL_TESTS();
+}
diff --git a/cpr/test/proxy_tests.cpp b/cpr/test/proxy_tests.cpp
new file mode 100644
index 0000000..7a6b865
--- /dev/null
+++ b/cpr/test/proxy_tests.cpp
@@ -0,0 +1,94 @@
+#include <gtest/gtest.h>
+
+#include <string>
+
+#include <cpr/cpr.h>
+
+// TODO: This uses public servers for proxies and endpoints. This should be replaced with a source
+// code implementation inside server.cpp
+
+#define HTTP_PROXY "104.131.214.38:3128"
+#define HTTPS_PROXY "104.131.214.38:3128"
+
+using namespace cpr;
+
+TEST(ProxyTests, SingleProxyTest) {
+    auto url = Url{"http://www.httpbin.org/get"};
+    auto response = cpr::Get(url, Proxies{{"http", HTTP_PROXY}});
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ProxyTests, MultipleProxyHttpTest) {
+    auto url = Url{"http://www.httpbin.org/get"};
+    auto response = cpr::Get(url, Proxies{{"http", HTTP_PROXY},
+                                          {"https", HTTPS_PROXY}});
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+// TODO: These should be fixed after a source code implementation of an HTTPS proxy
+#if defined(false)
+TEST(ProxyTests, ProxyHttpsTest) {
+    auto url = Url{"https://www.httpbin.org/get"};
+    auto response = cpr::Get(url, Proxies{{"https", HTTPS_PROXY}});
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ProxyTests, MultipleProxyHttpsTest) {
+    auto url = Url{"https://www.httpbin.org/get"};
+    auto response = cpr::Get(url, Proxies{{"http", HTTP_PROXY},
+                                          {"https", HTTPS_PROXY}});
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+#endif
+
+TEST(ProxyTests, CopyProxyTest) {
+    auto url = Url{"http://www.httpbin.org/get"};
+    auto proxies = Proxies{{"http", HTTP_PROXY}};
+    auto response = cpr::Get(url, proxies);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ProxyTests, ProxySessionTest) {
+    auto url = Url{"http://www.httpbin.org/get"};
+    Session session;
+    session.SetUrl(url);
+    session.SetProxies(Proxies{{"http", HTTP_PROXY}});
+    auto response = session.Get();
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ProxyTests, ReferenceProxySessionTest) {
+    auto url = Url{"http://www.httpbin.org/get"};
+    auto proxies = Proxies{{"http", HTTP_PROXY}};
+    Session session;
+    session.SetUrl(url);
+    session.SetProxies(proxies);
+    auto response = session.Get();
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    return RUN_ALL_TESTS();
+}
diff --git a/cpr/test/put_tests.cpp b/cpr/test/put_tests.cpp
new file mode 100644
index 0000000..5d2c9d5
--- /dev/null
+++ b/cpr/test/put_tests.cpp
@@ -0,0 +1,270 @@
+#include <gtest/gtest.h>
+
+#include <string>
+
+#include <cpr/cpr.h>
+
+#include "server.h"
+
+using namespace cpr;
+
+static Server* server = new Server();
+auto base = server->GetBaseUrl();
+
+TEST(PutTests, PutTest) {
+    auto url = Url{base + "/put.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto response = cpr::Put(url, payload);
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PutTests, PutUnallowedTest) {
+    auto url = Url{base + "/put_unallowed.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto response = cpr::Put(url, payload);
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PutTests, SessionPutTest) {
+    auto url = Url{base + "/put.html"};
+    auto payload = Payload{{"x", "5"}};
+    Session session;
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Put();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PutTests, SessionPutUnallowedTest) {
+    auto url = Url{base + "/put_unallowed.html"};
+    auto payload = Payload{{"x", "5"}};
+    Session session;
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Put();
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PutTests, SessionPutAfterGetTest) {
+    Session session;
+    {
+        auto url = Url{base + "/get.html"};
+        session.SetUrl(url);
+        auto response = session.Get();
+    }
+    auto url = Url{base + "/put.html"};
+    auto payload = Payload{{"x", "5"}};
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Put();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PutTests, SessionPutUnallowedAfterGetTest) {
+    Session session;
+    {
+        auto url = Url{base + "/get.html"};
+        session.SetUrl(url);
+        auto response = session.Get();
+    }
+    auto url = Url{base + "/put_unallowed.html"};
+    auto payload = Payload{{"x", "5"}};
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Put();
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PutTests, SessionPutAfterHeadTest) {
+    Session session;
+    {
+        auto url = Url{base + "/get.html"};
+        session.SetUrl(url);
+        auto response = session.Head();
+    }
+    auto url = Url{base + "/put.html"};
+    auto payload = Payload{{"x", "5"}};
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Put();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PutTests, SessionPutUnallowedAfterHeadTest) {
+    Session session;
+    {
+        auto url = Url{base + "/get.html"};
+        session.SetUrl(url);
+        auto response = session.Head();
+    }
+    auto url = Url{base + "/put_unallowed.html"};
+    auto payload = Payload{{"x", "5"}};
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Put();
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PutTests, SessionPutAfterPostTest) {
+    Session session;
+    {
+        auto url = Url{base + "/url_post.html"};
+        auto payload = Payload{{"x", "5"}};
+        session.SetUrl(url);
+        auto response = session.Post();
+    }
+    auto url = Url{base + "/put.html"};
+    auto payload = Payload{{"x", "5"}};
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Put();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PutTests, SessionPutUnallowedAfterPostTest) {
+    Session session;
+    {
+        auto url = Url{base + "/url_post.html"};
+        auto payload = Payload{{"x", "5"}};
+        session.SetUrl(url);
+        auto response = session.Post();
+    }
+    auto url = Url{base + "/put_unallowed.html"};
+    auto payload = Payload{{"x", "5"}};
+    session.SetUrl(url);
+    session.SetPayload(payload);
+    auto response = session.Put();
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PutTests, AsyncPutTest) {
+    auto url = Url{base + "/put.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto future_response = cpr::PutAsync(url, payload);
+    auto response = future_response.get();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PutTests, AsyncPutUnallowedTest) {
+    auto url = Url{base + "/put_unallowed.html"};
+    auto payload = Payload{{"x", "5"}};
+    auto future_response = cpr::PutAsync(url, payload);
+    auto response = future_response.get();
+    auto expected_text = std::string{"Method unallowed"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(405, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PutTests, AsyncMultiplePutTest) {
+    auto url = Url{base + "/put.html"};
+    auto payload = Payload{{"x", "5"}};
+    std::vector<AsyncResponse> responses;
+    for (int i = 0; i < 10; ++i) {
+        responses.emplace_back(cpr::PutAsync(url, payload));
+    }
+    for (auto& future_response : responses) {
+        auto response = future_response.get();
+        auto expected_text = std::string{"{\n"
+                                         "  \"x\": 5\n"
+                                         "}"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(PutTests, AsyncMultiplePutUnallowedTest) {
+    auto url = Url{base + "/put_unallowed.html"};
+    auto payload = Payload{{"x", "5"}};
+    std::vector<AsyncResponse> responses;
+    for (int i = 0; i < 10; ++i) {
+        responses.emplace_back(cpr::PutAsync(url, payload));
+    }
+    for (auto& future_response : responses) {
+        auto response = future_response.get();
+        auto expected_text = std::string{"Method unallowed"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(405, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    ::testing::AddGlobalTestEnvironment(server);
+    return RUN_ALL_TESTS();
+}
diff --git a/cpr/test/raw_body_tests.cpp b/cpr/test/raw_body_tests.cpp
new file mode 100644
index 0000000..fd9d7be
--- /dev/null
+++ b/cpr/test/raw_body_tests.cpp
@@ -0,0 +1,134 @@
+#include <gtest/gtest.h>
+
+#include <cstdio>
+#include <fstream>
+#include <string>
+
+#include <cpr/cpr.h>
+#include <cpr/multipart.h>
+
+#include "server.h"
+
+using namespace cpr;
+
+static Server* server = new Server();
+auto base = server->GetBaseUrl();
+
+TEST(BodyPostTests, DefaultUrlEncodedPostTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto response = cpr::Post(url, Body{"x=5"});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BodyPostTests, TextUrlEncodedPostTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto response = cpr::Post(url, Body{"x=hello world!!~"});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": hello world!!~\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BodyPostTests, TextUrlEncodedNoCopyPostTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto body = Body{"x=hello world!!~"};
+    // body lives through the lifetime of Post, so it doesn't need to be copied
+    auto response = cpr::Post(url, body);
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": hello world!!~\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BodyPostTests, UrlEncodedManyPostTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto response = cpr::Post(url, Body{"x=5&y=13"});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5,\n"
+                                     "  \"y\": 13,\n"
+                                     "  \"sum\": 18\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BodyPostTests, CustomHeaderNumberPostTest) {
+    auto url = Url{base + "/json_post.html"};
+    auto response = cpr::Post(url, Body{"{\"x\":5}"}, Header{{"Content-Type", "application/json"}});
+    auto expected_text = std::string{"{\"x\":5}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BodyPostTests, CustomHeaderTextPostTest) {
+    auto url = Url{base + "/json_post.html"};
+    auto response = cpr::Post(url, Body{"{\"x\":\"hello world!!~\"}"},
+                              Header{{"Content-Type", "application/json"}});
+    auto expected_text = std::string{"{\"x\":\"hello world!!~\"}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BodyPostTests, CustomWrongHeaderPostTest) {
+    auto url = Url{base + "/json_post.html"};
+    auto response = cpr::Post(url, Body{"{\"x\":5}"}, Header{{"Content-Type", "text/plain"}});
+    auto expected_text = std::string{"Unsupported Media Type"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(415, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BodyPostTests, UrlPostBadHostTest) {
+    auto url = Url{"http://bad_host/"};
+    auto response = cpr::Post(url, Body{"hello=world"});
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(0, response.status_code);
+    EXPECT_EQ(ErrorCode::HOST_RESOLUTION_FAILURE, response.error.code);
+}
+
+TEST(BodyPostTests, StringMoveBodyTest) {
+    auto url = Url{base + "/url_post.html"};
+    auto response = cpr::Post(url, Body{std::string{"x=5"}});
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    ::testing::AddGlobalTestEnvironment(server);
+    return RUN_ALL_TESTS();
+}
diff --git a/cpr/test/server.cpp b/cpr/test/server.cpp
new file mode 100644
index 0000000..b2985c6
--- /dev/null
+++ b/cpr/test/server.cpp
@@ -0,0 +1,701 @@
+#include "server.h"
+
+#include <chrono>
+#include <condition_variable>
+#include <cstdio>
+#include <mutex>
+#include <sstream>
+#include <thread>
+
+#include "mongoose.h"
+
+#include <time.h>
+
+#define SERVER_PORT "8080"
+
+std::mutex shutdown_mutex;
+std::mutex server_mutex;
+std::condition_variable server_cv;
+
+static const std::string base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+                                        "abcdefghijklmnopqrstuvwxyz"
+                                        "0123456789+/";
+
+static inline bool is_base64(unsigned char c);
+std::string base64_decode(std::string const& encoded_string);
+static int lowercase(const char *s);
+static int mg_strncasecmp(const char *s1, const char *s2, size_t len);
+
+static int options(struct mg_connection* conn) {
+    if (std::string{conn->request_method} == std::string{"OPTIONS"}) {
+        auto response = std::string{""};
+        mg_send_status(conn, 200);
+        mg_send_header(conn, "content-type", "text/html");
+        mg_send_header(conn, "Access-Control-Allow-Origin", "*");
+        mg_send_header(conn, "Access-Control-Allow-Credentials", "true");
+        mg_send_header(conn, "Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, PATCH, OPTIONS");
+        mg_send_header(conn, "Access-Control-Max-Age", "3600");
+        mg_send_data(conn, response.data(), response.length());
+    } else {
+        auto response = std::string{"Method unallowed"};
+        mg_send_status(conn, 405);
+        mg_send_header(conn, "content-type", "text/html");
+        mg_send_data(conn, response.data(), response.length());
+    }
+    return MG_TRUE;
+}
+
+static int hello(struct mg_connection* conn) {
+    if (std::string{conn->request_method} == std::string{"OPTIONS"}) {
+        auto response = std::string{""};
+        mg_send_status(conn, 200);
+        mg_send_header(conn, "content-type", "text/html");
+        mg_send_header(conn, "Access-Control-Allow-Origin", "*");
+        mg_send_header(conn, "Access-Control-Allow-Credentials", "true");
+        mg_send_header(conn, "Access-Control-Allow-Methods", "GET, OPTIONS");
+        mg_send_header(conn, "Access-Control-Max-Age", "3600");
+        mg_send_data(conn, response.data(), response.length());
+    } else {
+        auto response = std::string{"Hello world!"};
+        mg_send_status(conn, 200);
+        mg_send_header(conn, "content-type", "text/html");
+        mg_send_data(conn, response.data(), response.length());
+    }
+    return MG_TRUE;
+}
+
+static int timeout(struct mg_connection* conn) {
+    std::this_thread::sleep_for(std::chrono::milliseconds(10));
+    auto response = std::string{"Hello world!"};
+    mg_send_status(conn, 200);
+    mg_send_header(conn, "content-type", "text/html");
+    mg_send_data(conn, response.data(), response.length());
+    return MG_TRUE;
+}
+
+static int lowSpeed(struct mg_connection* conn) {
+    auto response = std::string{"Hello world!"};
+    mg_send_status(conn, 200);
+    mg_send_header(conn, "content-type", "text/html");
+    std::this_thread::sleep_for(std::chrono::seconds(2));
+    mg_send_data(conn, response.data(), response.length());
+    return MG_TRUE;
+}
+
+static int lowSpeedBytes(struct mg_connection* conn) {
+    auto response = std::string{"a"};
+    mg_send_status(conn, 200);
+    mg_send_header(conn, "content-type", "text/html");
+    for (auto i = 0; i < 20; ++i) {
+        std::this_thread::sleep_for(std::chrono::milliseconds(100));
+        mg_send_data(conn, response.data(), response.length());
+    }
+    return MG_TRUE;
+}
+
+static int basicCookies(struct mg_connection* conn) {
+    auto response = std::string{"Hello world!"};
+    mg_send_status(conn, 200);
+    mg_send_header(conn, "content-type", "text/html");
+    time_t t = time(NULL) + 5;  // Valid for 1 hour
+    char expire[100], expire_epoch[100];
+    snprintf(expire_epoch, sizeof(expire_epoch), "%lu", static_cast<unsigned long>(t));
+    strftime(expire, sizeof(expire), "%a, %d %b %Y %H:%M:%S GMT", gmtime(&t));
+    std::string cookie{"cookie=chocolate; expires=\"" + std::string{expire} + "\"; http-only;"};
+    std::string cookie2{"icecream=vanilla; expires=\"" + std::string{expire} + "\"; http-only;"};
+    mg_send_header(conn, "Set-Cookie", cookie.data());
+    mg_send_header(conn, "Set-Cookie", cookie2.data());
+    mg_send_data(conn, response.data(), response.length());
+    return MG_TRUE;
+}
+
+static int v1Cookies(struct mg_connection* conn) {
+    auto response = std::string{"Hello world!"};
+    mg_send_status(conn, 200);
+    mg_send_header(conn, "content-type", "text/html");
+    time_t t = time(NULL) + 5; // Valid for 1 hour
+    char expire[100], expire_epoch[100];
+    snprintf(expire_epoch, sizeof(expire_epoch), "%lu", static_cast<unsigned long>(t));
+    strftime(expire, sizeof(expire), "%a, %d %b %Y %H:%M:%S GMT", gmtime(&t));
+    std::string v1cookie{"cookie=\"value with spaces (v1 cookie)\"; expires=\"" +
+                         std::string{expire} + "\"; http-only;"};
+    mg_send_header(conn, "Set-Cookie", v1cookie.data());
+    mg_send_data(conn, response.data(), response.length());
+    return MG_TRUE;
+}
+
+static int checkBasicCookies(struct mg_connection* conn) {
+    const char* request_cookies;
+    if ((request_cookies = mg_get_header(conn, "Cookie")) == NULL)
+        return MG_FALSE;
+    std::string cookie_str{request_cookies};
+
+    if (cookie_str.find("cookie=chocolate;") == cookie_str.npos ||
+        cookie_str.find("icecream=vanilla;") == cookie_str.npos) {
+        return MG_FALSE;
+    }
+
+    auto response = std::string{"Hello world!"};
+    mg_send_status(conn, 200);
+    mg_send_header(conn, "content-type", "text/html");
+    mg_send_data(conn, response.data(), response.length());
+    return MG_TRUE;
+}
+
+static int checkV1Cookies(struct mg_connection* conn) {
+    const char* request_cookies;
+    if ((request_cookies = mg_get_header(conn, "Cookie")) == NULL)
+        return MG_FALSE;
+    std::string cookie_str{request_cookies};
+
+    if (cookie_str.find("cookie=\"value with spaces (v1 cookie)\";") == cookie_str.npos) {
+        return MG_FALSE;
+    }
+
+    auto response = std::string{"Hello world!"};
+    mg_send_status(conn, 200);
+    mg_send_header(conn, "content-type", "text/html");
+    mg_send_data(conn, response.data(), response.length());
+    return MG_TRUE;
+}
+
+static int basicAuth(struct mg_connection* conn) {
+    auto response = std::string{"Hello world!"};
+    const char* requested_auth;
+    auto auth = std::string{"Basic"};
+    if ((requested_auth = mg_get_header(conn, "Authorization")) == NULL ||
+        mg_strncasecmp(requested_auth, auth.data(), auth.length()) != 0) {
+        return MG_FALSE;
+    }
+    auto auth_string = std::string{requested_auth};
+    auto basic_token = auth_string.find(' ') + 1;
+    auth_string = auth_string.substr(basic_token, auth_string.length() - basic_token);
+    auth_string = base64_decode(auth_string);
+    auto colon = auth_string.find(':');
+    auto username = auth_string.substr(0, colon);
+    auto password = auth_string.substr(colon + 1, auth_string.length() - colon - 1);
+    if (username == "user" && password == "password") {
+        return MG_TRUE;
+    }
+
+    return MG_FALSE;
+}
+
+static int digestAuth(struct mg_connection* conn) {
+    int result = MG_FALSE;
+    {
+        FILE *fp;
+        if ((fp = fopen("digest.txt", "w")) != NULL) {
+            fprintf(fp, "user:mydomain.com:0cf722ef3dd136b48da83758c5d855f8\n");
+            fclose(fp);
+        }
+    }
+
+    {
+        FILE *fp;
+        if ((fp = fopen("digest.txt", "r")) != NULL) {
+            result = mg_authorize_digest(conn, fp);
+            fclose(fp);
+        }
+    }
+
+    return result;
+}
+
+static int basicJson(struct mg_connection* conn) {
+    auto response = std::string{"[\n"
+                                "  {\n"
+                                "    \"first_key\": \"first_value\",\n"
+                                "    \"second_key\": \"second_value\"\n"
+                                "  }\n"
+                                "]"};
+    mg_send_status(conn, 200);
+    auto raw_header = mg_get_header(conn, "Content-type");
+    std::string header;
+    if (raw_header != NULL) {
+        header = raw_header;
+    }
+    if (!header.empty() && header == "application/json") {
+        mg_send_header(conn, "content-type", "application/json");
+    } else {
+        mg_send_header(conn, "content-type", "application/octet-stream");
+    }
+    mg_send_data(conn, response.data(), response.length());
+    return MG_TRUE;
+}
+
+static int headerReflect(struct mg_connection* conn) {
+    auto response = std::string{"Header reflect "} +
+                    std::string{conn->request_method};
+    mg_send_status(conn, 200);
+    mg_send_header(conn, "content-type", "text/html");
+    auto num_headers = conn->num_headers;
+    auto headers = conn->http_headers;
+    for (int i = 0; i < num_headers; ++i) {
+        auto name = headers[i].name;
+        if (std::string{"User-Agent"} != name &&
+                std::string{"Host"} != name &&
+                std::string{"Accept"} != name) {
+            mg_send_header(conn, name, headers[i].value);
+        }
+    }
+    mg_send_data(conn, response.data(), response.length());
+    return MG_TRUE;
+}
+
+static int temporaryRedirect(struct mg_connection* conn) {
+    auto response = std::string{"Found"};
+    mg_send_status(conn, 302);
+    mg_send_header(conn, "Location", "hello.html");
+    mg_send_data(conn, response.data(), response.length());
+    return MG_TRUE;
+}
+
+static int permanentRedirect(struct mg_connection* conn) {
+    auto response = std::string{"Moved Permanently"};
+    mg_send_status(conn, 301);
+    mg_send_header(conn, "Location", "hello.html");
+    mg_send_data(conn, response.data(), response.length());
+    return MG_TRUE;
+}
+
+static int twoRedirects(struct mg_connection* conn) {
+    auto response = std::string{"Moved Permanently"};
+    mg_send_status(conn, 301);
+    mg_send_header(conn, "Location", "permanent_redirect.html");
+    mg_send_data(conn, response.data(), response.length());
+    return MG_TRUE;
+}
+
+static int bodyGet(struct mg_connection* conn) {
+    char message[100];
+    mg_get_var(conn, "Message", message, sizeof(message));
+    auto response = std::string{message};
+    mg_send_status(conn, 200);
+    mg_send_header(conn, "content-type", "text/html");
+    mg_send_data(conn, response.data(), response.length());
+    return MG_TRUE;
+}
+
+static int urlPost(struct mg_connection* conn) {
+    mg_send_status(conn, 201);
+    mg_send_header(conn, "content-type", "application/json");
+    char x[100];
+    char y[100];
+    mg_get_var(conn, "x", x, sizeof(x));
+    mg_get_var(conn, "y", y, sizeof(y));
+    auto x_string = std::string{x};
+    auto y_string = std::string{y};
+    if (y_string.empty()) {
+        auto response = std::string{"{\n"
+                                    "  \"x\": " + x_string + "\n"
+                                    "}"};
+        mg_send_data(conn, response.data(), response.length());
+    } else {
+        std::ostringstream s;
+        s << (atoi(x) + atoi(y));
+        auto response = std::string{"{\n"
+                                    "  \"x\": " + x_string + ",\n"
+                                    "  \"y\": " + y_string + ",\n"
+                                    "  \"sum\": " + s.str() + "\n"
+                                    "}"};
+        mg_send_data(conn, response.data(), response.length());
+    }
+    return MG_TRUE;
+}
+
+static int jsonPost(struct mg_connection* conn) {
+    auto num_headers = conn->num_headers;
+    auto headers = conn->http_headers;
+    auto has_json_header = false;
+    for (int i = 0; i < num_headers; ++i) {
+        if (std::string{"Content-Type"} == headers[i].name &&
+                std::string{"application/json"} == headers[i].value) {
+            has_json_header = true;
+        }
+    }
+    if (!has_json_header) {
+        auto response = std::string{"Unsupported Media Type"};
+        mg_send_status(conn, 415);
+        mg_send_header(conn, "content-type", "text/html");
+        mg_send_data(conn, response.data(), response.length());
+        return MG_TRUE;
+    }
+    mg_send_status(conn, 201);
+    mg_send_header(conn, "content-type", "application/json");
+    auto response = std::string{conn->content, conn->content_len};
+    mg_send_data(conn, response.data(), response.length());
+    return MG_TRUE;
+}
+
+static int formPost(struct mg_connection* conn) {
+    auto content = conn->content;
+    auto content_len = conn->content_len;
+
+    std::map<std::string, std::string> forms;
+
+    while (true) {
+        char* data = new char[10000];
+        int data_len;
+        char name[100];
+        char filename[100];
+        auto read_len = mg_parse_multipart(content, content_len,
+                                           name, sizeof(name),
+                                           filename, sizeof(filename),
+                                           const_cast<const char**>(&data), &data_len);
+        if (read_len == 0) {
+            delete[] data;
+            break;
+        }
+
+        content += read_len;
+        content_len -= read_len;
+
+        if (strlen(data) == 0) {
+            delete[] data;
+            break;
+        }
+
+        forms[name] = std::string{data, static_cast<unsigned long>(data_len)};
+    }
+
+    mg_send_status(conn, 201);
+    mg_send_header(conn, "content-type", "application/json");
+    if (forms.find("y") == forms.end()) {
+        auto response = std::string{"{\n"
+                                    "  \"x\": " + forms["x"] + "\n"
+                                    "}"};
+        mg_send_data(conn, response.data(), response.length());
+    } else {
+        std::ostringstream s;
+        s << (atoi(forms["x"].data()) + atoi(forms["y"].data()));
+        auto response = std::string{"{\n"
+                                    "  \"x\": " + forms["x"] + ",\n"
+                                    "  \"y\": " + forms["y"] + ",\n"
+                                    "  \"sum\": " + s.str() + "\n"
+                                    "}"};
+        mg_send_data(conn, response.data(), response.length());
+    }
+    return MG_TRUE;
+}
+
+static int deleteRequest(struct mg_connection* conn) {
+    auto num_headers = conn->num_headers;
+    auto headers = conn->http_headers;
+    auto has_json_header = false;
+    for (int i = 0; i < num_headers; ++i) {
+        if (std::string{"Content-Type"} == headers[i].name &&
+                std::string{"application/json"} == headers[i].value) {
+            has_json_header = true;
+        }
+    }
+    if (std::string{conn->request_method} == std::string{"DELETE"}) {
+      if (!has_json_header) {
+          auto response = std::string{"Delete success"};
+          mg_send_status(conn, 200);
+          mg_send_header(conn, "content-type", "text/html");
+          mg_send_data(conn, response.data(), response.length());
+      } else {
+          auto response = std::string{conn->content, conn->content_len};
+          mg_send_status(conn, 200);
+          mg_send_header(conn, "content-type", "application/json");
+          mg_send_data(conn, response.data(), response.length());
+      }
+    } else {
+        auto response = std::string{"Method unallowed"};
+        mg_send_status(conn, 405);
+        mg_send_header(conn, "content-type", "text/html");
+        mg_send_data(conn, response.data(), response.length());
+    }
+    return MG_TRUE;
+}
+
+static int deleteUnallowedRequest(struct mg_connection* conn) {
+    if (std::string{conn->request_method} == std::string{"DELETE"}) {
+        auto response = std::string{"Method unallowed"};
+        mg_send_status(conn, 405);
+        mg_send_header(conn, "content-type", "text/html");
+        mg_send_data(conn, response.data(), response.length());
+    } else {
+        auto response = std::string{"Delete success"};
+        mg_send_status(conn, 200);
+        mg_send_header(conn, "content-type", "text/html");
+        mg_send_data(conn, response.data(), response.length());
+    }
+    return MG_TRUE;
+}
+
+static int patch(struct mg_connection* conn) {
+    if (std::string{conn->request_method} == std::string{"PATCH"}) {
+        mg_send_status(conn, 200);
+        mg_send_header(conn, "content-type", "application/json");
+        char x[100];
+        char y[100];
+        mg_get_var(conn, "x", x, sizeof(x));
+        mg_get_var(conn, "y", y, sizeof(y));
+        auto x_string = std::string{x};
+        auto y_string = std::string{y};
+        if (y_string.empty()) {
+            auto response = std::string{"{\n"
+                                        "  \"x\": " + x_string + "\n"
+                                        "}"};
+            mg_send_data(conn, response.data(), response.length());
+        } else {
+            std::ostringstream s;
+            s << (atoi(x) + atoi(y));
+            auto response = std::string{"{\n"
+                                        "  \"x\": " + x_string + ",\n"
+                                        "  \"y\": " + y_string + ",\n"
+                                        "  \"sum\": " + s.str() + "\n"
+                                        "}"};
+            mg_send_data(conn, response.data(), response.length());
+        }
+    } else {
+        auto response = std::string{"Method unallowed"};
+        mg_send_status(conn, 405);
+        mg_send_header(conn, "content-type", "text/html");
+        mg_send_data(conn, response.data(), response.length());
+    }
+    return MG_TRUE;
+}
+
+static int patchUnallowed(struct mg_connection* conn) {
+    if (std::string{conn->request_method} == std::string{"PATCH"}) {
+        auto response = std::string{"Method unallowed"};
+        mg_send_status(conn, 405);
+        mg_send_header(conn, "content-type", "text/html");
+        mg_send_data(conn, response.data(), response.length());
+    } else {
+        auto response = std::string{"Patch success"};
+        mg_send_status(conn, 200);
+        mg_send_header(conn, "content-type", "text/html");
+        mg_send_data(conn, response.data(), response.length());
+    }
+    return MG_TRUE;
+}
+
+static int put(struct mg_connection* conn) {
+    if (std::string{conn->request_method} == std::string{"PUT"}) {
+        mg_send_status(conn, 200);
+        mg_send_header(conn, "content-type", "application/json");
+        char x[100];
+        char y[100];
+        mg_get_var(conn, "x", x, sizeof(x));
+        mg_get_var(conn, "y", y, sizeof(y));
+        auto x_string = std::string{x};
+        auto y_string = std::string{y};
+        if (y_string.empty()) {
+            auto response = std::string{"{\n"
+                                        "  \"x\": " + x_string + "\n"
+                                        "}"};
+            mg_send_data(conn, response.data(), response.length());
+        } else {
+            std::ostringstream s;
+            s << (atoi(x) + atoi(y));
+            auto response = std::string{"{\n"
+                                        "  \"x\": " + x_string + ",\n"
+                                        "  \"y\": " + y_string + ",\n"
+                                        "  \"sum\": " + s.str() + "\n"
+                                        "}"};
+            mg_send_data(conn, response.data(), response.length());
+        }
+    } else {
+        auto response = std::string{"Method unallowed"};
+        mg_send_status(conn, 405);
+        mg_send_header(conn, "content-type", "text/html");
+        mg_send_data(conn, response.data(), response.length());
+    }
+    return MG_TRUE;
+}
+
+static int putUnallowed(struct mg_connection* conn) {
+    if (std::string{conn->request_method} == std::string{"PUT"}) {
+        auto response = std::string{"Method unallowed"};
+        mg_send_status(conn, 405);
+        mg_send_header(conn, "content-type", "text/html");
+        mg_send_data(conn, response.data(), response.length());
+    } else {
+        auto response = std::string{"Put success"};
+        mg_send_status(conn, 200);
+        mg_send_header(conn, "content-type", "text/html");
+        mg_send_data(conn, response.data(), response.length());
+    }
+    return MG_TRUE;
+}
+
+static int evHandler(struct mg_connection* conn, enum mg_event ev) {
+    switch (ev) {
+        case MG_AUTH:
+            if (Url{conn->uri} == "/basic_auth.html") {
+                return basicAuth(conn);
+            } else if (Url{conn->uri} == "/digest_auth.html") {
+                return digestAuth(conn);
+            }
+            return MG_TRUE;
+        case MG_REQUEST:
+            if (Url{conn->uri} == "/") {
+                return options(conn);
+            } else if (Url{conn->uri} == "/hello.html") {
+                return hello(conn);
+            } else if (Url{conn->uri} == "/timeout.html") {
+                return timeout(conn);
+            } else if (Url{conn->uri} == "/low_speed.html") {
+                return lowSpeed(conn);
+            } else if (Url{conn->uri} == "/low_speed_bytes.html") {
+                return lowSpeedBytes(conn);
+            } else if (Url{conn->uri} == "/basic_cookies.html") {
+                return basicCookies(conn);
+            } else if (Url{conn->uri} == "/check_cookies.html") {
+                return checkBasicCookies(conn);
+            } else if (Url{conn->uri} == "/v1_cookies.html") {
+                return v1Cookies(conn);
+            } else if (Url{conn->uri} == "/check_v1_cookies.html") {
+                return checkV1Cookies(conn);
+            } else if (Url{conn->uri} == "/basic_auth.html") {
+                return headerReflect(conn);
+            } else if (Url{conn->uri} == "/digest_auth.html") {
+                return headerReflect(conn);
+            } else if (Url{conn->uri} == "/basic.json") {
+                return basicJson(conn);
+            } else if (Url{conn->uri} == "/header_reflect.html") {
+                return headerReflect(conn);
+            } else if (Url{conn->uri} == "/temporary_redirect.html") {
+                return temporaryRedirect(conn);
+            } else if (Url{conn->uri} == "/permanent_redirect.html") {
+                return permanentRedirect(conn);
+            } else if (Url{conn->uri} == "/two_redirects.html") {
+                return twoRedirects(conn);
+            } else if (Url{conn->uri} == "/url_post.html") {
+                return urlPost(conn);
+            } else if (Url{conn->uri} == "/body_get.html") {
+                return bodyGet(conn);
+            } else if (Url{conn->uri} == "/json_post.html") {
+                return jsonPost(conn);
+            } else if (Url{conn->uri} == "/form_post.html") {
+                return formPost(conn);
+            } else if (Url{conn->uri} == "/delete.html") {
+                return deleteRequest(conn);
+            } else if (Url{conn->uri} == "/delete_unallowed.html") {
+                return deleteUnallowedRequest(conn);
+            } else if (Url{conn->uri} == "/put.html") {
+                return put(conn);
+            } else if (Url{conn->uri} == "/put_unallowed.html") {
+                return putUnallowed(conn);
+            } else if (Url{conn->uri} == "/patch.html") {
+                return patch(conn);
+            } else if (Url{conn->uri} == "/patch_unallowed.html") {
+                return patchUnallowed(conn);
+            }
+            return MG_FALSE;
+        default:
+            return MG_FALSE;
+    }
+}
+
+void runServer(struct mg_server* server) {
+    {
+        std::lock_guard<std::mutex> server_lock(server_mutex);
+        mg_set_option(server, "listening_port", SERVER_PORT);
+        server_cv.notify_one();
+    }
+
+    do {
+        mg_poll_server(server, 1000);
+    } while (!shutdown_mutex.try_lock());
+
+    shutdown_mutex.unlock();
+    std::lock_guard<std::mutex> server_lock(server_mutex);
+    mg_destroy_server(&server);
+    server_cv.notify_one();
+}
+
+void Server::SetUp() {
+    shutdown_mutex.lock();
+    struct mg_server* server;
+    server = mg_create_server(NULL, evHandler);
+    std::unique_lock<std::mutex> server_lock(server_mutex);
+    std::thread(runServer, server).detach();
+    server_cv.wait(server_lock);
+}
+
+void Server::TearDown() {
+    std::unique_lock<std::mutex> server_lock(server_mutex);
+    shutdown_mutex.unlock();
+    server_cv.wait(server_lock);
+}
+
+Url Server::GetBaseUrl() {
+    return Url{"http://127.0.0.1:"}.append(SERVER_PORT);
+}
+
+Url Server::GetBaseUrlSSL() {
+    return Url{"https://127.0.0.1:"}.append(SERVER_PORT);
+}
+
+static inline bool is_base64(unsigned char c) {
+    return (isalnum(c) || (c == '+') || (c == '/'));
+}
+
+std::string base64_decode(std::string const& encoded_string) {
+    int in_len = encoded_string.size();
+    int i = 0;
+    int j = 0;
+    int in_ = 0;
+    unsigned char char_array_4[4], char_array_3[3];
+    std::string ret;
+
+    while (in_len-- && ( encoded_string[in_] != '=') && is_base64(encoded_string[in_])) {
+        char_array_4[i++] = encoded_string[in_]; in_++;
+        if (i ==4) {
+            for (i = 0; i <4; i++) {
+                char_array_4[i] = base64_chars.find(char_array_4[i]);
+            }
+
+            char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
+            char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
+            char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
+
+            for (i = 0; (i < 3); i++) {
+                ret += char_array_3[i];
+            }
+
+            i = 0;
+        }
+    }
+
+    if (i) {
+        for (j = i; j <4; j++) {
+            char_array_4[j] = 0;
+        }
+
+        for (j = 0; j <4; j++) {
+            char_array_4[j] = base64_chars.find(char_array_4[j]);
+        }
+
+        char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
+        char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
+        char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
+
+        for (j = 0; (j < i - 1); j++) {
+            ret += char_array_3[j];
+        }
+    }
+
+    return ret;
+}
+
+static int lowercase(const char *s) {
+    return tolower(* reinterpret_cast<const unsigned char *>(s));
+}
+
+static int mg_strncasecmp(const char *s1, const char *s2, size_t len) {
+    int diff = 0;
+
+    if (len > 0) {
+        do {
+            diff = lowercase(s1++) - lowercase(s2++);
+        } while (diff == 0 && s1[-1] != '\0' && --len > 0);
+    }
+
+    return diff;
+}
diff --git a/cpr/test/server.h b/cpr/test/server.h
new file mode 100644
index 0000000..16e0bbd
--- /dev/null
+++ b/cpr/test/server.h
@@ -0,0 +1,21 @@
+#ifndef CPR_TEST_SERVER_H
+#define CPR_TEST_SERVER_H
+
+#include <string>
+
+#include <gtest/gtest.h>
+
+#include <cpr/cpr.h>
+
+using namespace cpr;
+
+class Server: public ::testing::Environment {
+  public:
+    virtual void SetUp();
+    virtual void TearDown();
+
+    Url GetBaseUrl();
+    Url GetBaseUrlSSL();
+};
+
+#endif
diff --git a/cpr/test/session_tests.cpp b/cpr/test/session_tests.cpp
new file mode 100644
index 0000000..8acf6a2
--- /dev/null
+++ b/cpr/test/session_tests.cpp
@@ -0,0 +1,776 @@
+#include <gtest/gtest.h>
+
+#include <chrono>
+#include <string>
+
+#include <cpr/cpr.h>
+
+#include "server.h"
+
+using namespace cpr;
+
+static Server* server = new Server();
+auto base = server->GetBaseUrl();
+
+TEST(RedirectTests, TemporaryDefaultRedirectTest) {
+    auto url = Url{base + "/temporary_redirect.html"};
+    Session session;
+    session.SetUrl(url);
+    auto response = session.Get();
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{base + "/hello.html"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(RedirectTests, NoTemporaryRedirectTest) {
+    auto url = Url{base + "/temporary_redirect.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetRedirect(false);
+    auto response = session.Get();
+    auto expected_text = std::string{"Found"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(302, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(RedirectTests, PermanentDefaultRedirectTest) {
+    auto url = Url{base + "/permanent_redirect.html"};
+    Session session;
+    session.SetUrl(url);
+    auto response = session.Get();
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{base + "/hello.html"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(RedirectTests, NoPermanentRedirectTest) {
+    auto url = Url{base + "/permanent_redirect.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetRedirect(false);
+    auto response = session.Get();
+    auto expected_text = std::string{"Moved Permanently"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(301, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(MaxRedirectsTests, ZeroMaxRedirectsSuccessTest) {
+    auto url = Url{base + "/hello.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetMaxRedirects(MaxRedirects(0));
+    auto response = session.Get();
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(MaxRedirectsTests, ZeroMaxRedirectsFailureTest) {
+    auto url = Url{base + "/permanent_redirect.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetMaxRedirects(MaxRedirects(0));
+    auto response = session.Get();
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(301, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(MaxRedirectsTests, OneMaxRedirectsSuccessTest) {
+    auto url = Url{base + "/permanent_redirect.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetMaxRedirects(MaxRedirects(1));
+    auto response = session.Get();
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{base + "/hello.html"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(MaxRedirectsTests, OneMaxRedirectsFailureTest) {
+    auto url = Url{base + "/two_redirects.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetMaxRedirects(MaxRedirects(1));
+    auto response = session.Get();
+    EXPECT_EQ(std::string{}, response.text);
+    EXPECT_EQ(Url{base + "/permanent_redirect.html"}, response.url);
+    EXPECT_EQ(std::string{}, response.header["content-type"]);
+    EXPECT_EQ(301, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(MaxRedirectsTests, TwoMaxRedirectsSuccessTest) {
+    auto url = Url{base + "/two_redirects.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetMaxRedirects(MaxRedirects(2));
+    auto response = session.Get();
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{base + "/hello.html"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(MultipleGetTests, BasicMultipleGetTest) {
+    auto url = Url{base + "/hello.html"};
+    Session session;
+    session.SetUrl(url);
+    for (int i = 0; i < 100; ++i) {
+        auto response = session.Get();
+        auto expected_text = std::string{"Hello world!"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(MultipleGetTests, UrlChangeMultipleGetTest) {
+    Session session;
+    {
+        auto url = Url{base + "/hello.html"};
+        session.SetUrl(url);
+        auto response = session.Get();
+        auto expected_text = std::string{"Hello world!"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+    {
+        auto url = Url{base + "/basic.json"};
+        session.SetUrl(url);
+        auto response = session.Get();
+        auto expected_text = std::string{"[\n"
+                                         "  {\n"
+                                         "    \"first_key\": \"first_value\",\n"
+                                         "    \"second_key\": \"second_value\"\n"
+                                         "  }\n"
+                                         "]"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"application/octet-stream"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(MultipleGetTests, HeaderMultipleGetTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetHeader(Header{{"hello", "world"}});
+    for (int i = 0; i < 100; ++i) {
+        auto response = session.Get();
+        auto expected_text = std::string{"Header reflect GET"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(MultipleGetTests, HeaderChangeMultipleGetTest) {
+    auto url = Url{base + "/header_reflect.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetHeader(Header{{"hello", "world"}});
+    {
+        auto response = session.Get();
+        auto expected_text = std::string{"Header reflect GET"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(std::string{"world"}, response.header["hello"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+    session.SetHeader(Header{{"key", "value"}});
+    {
+        auto response = session.Get();
+        auto expected_text = std::string{"Header reflect GET"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(std::string{"value"}, response.header["key"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(MultipleGetTests, ParameterMultipleGetTest) {
+    auto url = Url{base + "/hello.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetParameters({{"hello", "world"}});
+    for (int i = 0; i < 100; ++i) {
+        auto response = session.Get();
+        auto expected_text = std::string{"Hello world!"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(Url{url + "?hello=world"}, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(MultipleGetTests, ParameterChangeMultipleGetTest) {
+    auto url = Url{base + "/hello.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetParameters({{"hello", "world"}});
+    {
+        auto response = session.Get();
+        auto expected_text = std::string{"Hello world!"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(Url{url + "?hello=world"}, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+    session.SetUrl(url);
+    session.SetParameters({{"key", "value"}});
+    {
+        auto response = session.Get();
+        auto expected_text = std::string{"Hello world!"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(Url{url + "?key=value"}, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(MultipleGetTests, BasicAuthenticationMultipleGetTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetAuth(Authentication{"user", "password"});
+    for (int i = 0; i < 100; ++i) {
+        auto response = session.Get();
+        auto expected_text = std::string{"Header reflect GET"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(MultipleGetTests, BasicAuthenticationChangeMultipleGetTest) {
+    auto url = Url{base + "/basic_auth.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetAuth(Authentication{"user", "password"});
+    {
+        auto response = session.Get();
+        auto expected_text = std::string{"Header reflect GET"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+    session.SetAuth(Authentication{"user", "bad_password"});
+    {
+        auto response = session.Get();
+        EXPECT_EQ(std::string{}, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{}, response.header["content-type"]);
+        EXPECT_EQ(401, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+    session.SetAuth(Authentication{"bad_user", "password"});
+    {
+        auto response = session.Get();
+        EXPECT_EQ(std::string{}, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{}, response.header["content-type"]);
+        EXPECT_EQ(401, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(ParameterTests, ParameterSingleTest) {
+    auto url = Url{base + "/hello.html"};
+    Session session;
+    session.SetUrl(url);
+    Parameters parameters{{"hello", "world"}};
+    session.SetParameters(parameters);
+    auto response = session.Get();
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?hello=world"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(ParameterTests, ParameterMultipleTest) {
+    auto url = Url{base + "/hello.html"};
+    Session session;
+    session.SetUrl(url);
+    Parameters parameters{{"hello", "world"}, {"key", "value"}};
+    session.SetParameters(parameters);
+    auto response = session.Get();
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(Url{url + "?hello=world&key=value"}, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(TimeoutTests, SetTimeoutTest) {
+    auto url = Url{base + "/hello.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetTimeout(0L);
+    auto response = session.Get();
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(TimeoutTests, SetTimeoutLongTest) {
+    auto url = Url{base + "/hello.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetTimeout(10000L);
+    auto response = session.Get();
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(TimeoutTests, SetChronoTimeoutTest) {
+    auto url = Url{base + "/hello.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetTimeout(std::chrono::milliseconds{0});
+    auto response = session.Get();
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(TimeoutTests, SetChronoTimeoutLongTest) {
+    auto url = Url{base + "/hello.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetTimeout(std::chrono::milliseconds{10000});
+    auto response = session.Get();
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(LowSpeedTests, SetLowSpeedTest) {
+    auto url = Url{base + "/hello.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetLowSpeed({1, 1});
+    auto response = session.Get();
+    auto expected_text = std::string{"Hello world!"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PayloadTests, SetPayloadTest) {
+    auto url = Url{base + "/url_post.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetPayload({{"x", "5"}});
+    auto response = session.Post();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(PayloadTests, SetPayloadLValueTest) {
+    auto url = Url{base + "/url_post.html"};
+    Session session;
+    session.SetUrl(url);
+    auto payload = Payload{{"x", "5"}};
+    session.SetPayload(payload);
+    auto response = session.Post();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(MultipartTests, SetMultipartTest) {
+    auto url = Url{base + "/form_post.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetMultipart({{"x", "5"}});
+    auto response = session.Post();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(MultipartTests, SetMultipartValueTest) {
+    auto url = Url{base + "/form_post.html"};
+    Session session;
+    session.SetUrl(url);
+    auto multipart = Multipart{{"x", "5"}};
+    session.SetMultipart(multipart);
+    auto response = session.Post();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BodyTests, SetBodyTest) {
+    auto url = Url{base + "/url_post.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetBody(Body{"x=5"});
+    auto response = session.Post();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(BodyTests, SetBodyValueTest) {
+    auto url = Url{base + "/url_post.html"};
+    Session session;
+    session.SetUrl(url);
+    auto body = Body{"x=5"};
+    session.SetBody(body);
+    auto response = session.Post();
+    auto expected_text = std::string{"{\n"
+                                     "  \"x\": 5\n"
+                                     "}"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+    EXPECT_EQ(201, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(DigestTests, SetDigestTest) {
+    auto url = Url{base + "/digest_auth.html"};
+    Session session;
+    session.SetUrl(url);
+    session.SetDigest({"user", "password"});
+    auto response = session.Get();
+    auto expected_text = std::string{"Header reflect GET"};
+    EXPECT_EQ(expected_text, response.text);
+    EXPECT_EQ(url, response.url);
+    EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+    EXPECT_EQ(200, response.status_code);
+    EXPECT_EQ(ErrorCode::OK, response.error.code);
+}
+
+TEST(CookiesTests, BasicCookiesTest) {
+    auto url = Url{base + "/basic_cookies.html"};
+    Session session{};
+    session.SetUrl(url);
+    Cookies cookies;
+
+    {
+        auto response = session.Get();
+        auto expected_text = std::string{"Hello world!"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+        cookies = response.cookies;
+    }
+    {
+        cookies["hello"] = "world";
+        cookies["my"] = "another; fake=cookie;"; // This is url encoded
+        session.SetCookies(cookies);
+        auto response = session.Get();
+        auto expected_text = std::string{"Hello world!"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+        EXPECT_EQ(cookies["cookie"], response.cookies["cookie"]);
+        EXPECT_EQ(cookies["icecream"], response.cookies["icecream"]);
+        EXPECT_EQ(cookies["expires"], response.cookies["expires"]);
+    }
+}
+
+TEST(CookiesTests, CookiesConstructorTest) {
+    auto url = Url{base + "/basic_cookies.html"};
+    Session session{};
+    session.SetUrl(url);
+    Cookies cookies;
+
+    {
+        auto response = session.Get();
+        auto expected_text = std::string{"Hello world!"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+        cookies = response.cookies;
+    }
+    {
+        cookies = Cookies{{"hello", "world"}, {"my", "another; fake=cookie;"}};
+        session.SetCookies(cookies);
+        auto response = session.Get();
+        auto expected_text = std::string{"Hello world!"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+        cookies = response.cookies;
+        EXPECT_EQ(cookies["cookie"], response.cookies["cookie"]);
+        EXPECT_EQ(cookies["icecream"], response.cookies["icecream"]);
+        EXPECT_EQ(cookies["expires"], response.cookies["expires"]);
+    }
+}
+
+TEST(DifferentMethodTests, GetPostTest) {
+    Session session;
+    {
+        auto url = Url{base + "/hello.html"};
+        session.SetUrl(url);
+        auto response = session.Get();
+        auto expected_text = std::string{"Hello world!"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+    {
+        auto url = Url{base + "/url_post.html"};
+        session.SetUrl(url);
+        session.SetPayload({{"x", "5"}});
+        auto response = session.Post();
+        auto expected_text = std::string{"{\n"
+                                         "  \"x\": 5\n"
+                                         "}"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+        EXPECT_EQ(201, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(DifferentMethodTests, PostGetTest) {
+    Session session;
+    {
+        auto url = Url{base + "/url_post.html"};
+        session.SetUrl(url);
+        session.SetPayload({{"x", "5"}});
+        auto response = session.Post();
+        auto expected_text = std::string{"{\n"
+                                         "  \"x\": 5\n"
+                                         "}"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+        EXPECT_EQ(201, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+    {
+        auto url = Url{base + "/hello.html"};
+        session.SetUrl(url);
+        auto response = session.Get();
+        auto expected_text = std::string{"Hello world!"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(DifferentMethodTests, GetPostGetTest) {
+    Session session;
+    {
+        auto url = Url{base + "/hello.html"};
+        session.SetUrl(url);
+        auto response = session.Get();
+        auto expected_text = std::string{"Hello world!"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+    {
+        auto url = Url{base + "/url_post.html"};
+        session.SetUrl(url);
+        session.SetPayload({{"x", "5"}});
+        auto response = session.Post();
+        auto expected_text = std::string{"{\n"
+                                         "  \"x\": 5\n"
+                                         "}"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+        EXPECT_EQ(201, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+    {
+        auto url = Url{base + "/hello.html"};
+        session.SetUrl(url);
+        auto response = session.Get();
+        auto expected_text = std::string{"Hello world!"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(DifferentMethodTests, PostGetPostTest) {
+    Session session;
+    {
+        auto url = Url{base + "/url_post.html"};
+        session.SetUrl(url);
+        session.SetPayload({{"x", "5"}});
+        auto response = session.Post();
+        auto expected_text = std::string{"{\n"
+                                         "  \"x\": 5\n"
+                                         "}"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+        EXPECT_EQ(201, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+    {
+        auto url = Url{base + "/hello.html"};
+        session.SetUrl(url);
+        auto response = session.Get();
+        auto expected_text = std::string{"Hello world!"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+        EXPECT_EQ(200, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+    {
+        auto url = Url{base + "/url_post.html"};
+        session.SetUrl(url);
+        session.SetPayload({{"x", "5"}});
+        auto response = session.Post();
+        auto expected_text = std::string{"{\n"
+                                         "  \"x\": 5\n"
+                                         "}"};
+        EXPECT_EQ(expected_text, response.text);
+        EXPECT_EQ(url, response.url);
+        EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+        EXPECT_EQ(201, response.status_code);
+        EXPECT_EQ(ErrorCode::OK, response.error.code);
+    }
+}
+
+TEST(DifferentMethodTests, MultipleGetPostTest) {
+    Session session;
+    for (int i = 0; i < 100; ++i) {
+        {
+            auto url = Url{base + "/hello.html"};
+            session.SetUrl(url);
+            auto response = session.Get();
+            auto expected_text = std::string{"Hello world!"};
+            EXPECT_EQ(expected_text, response.text);
+            EXPECT_EQ(url, response.url);
+            EXPECT_EQ(std::string{"text/html"}, response.header["content-type"]);
+            EXPECT_EQ(200, response.status_code);
+            EXPECT_EQ(ErrorCode::OK, response.error.code);
+        }
+        {
+            auto url = Url{base + "/url_post.html"};
+            session.SetUrl(url);
+            session.SetPayload({{"x", "5"}});
+            auto response = session.Post();
+            auto expected_text = std::string{"{\n"
+                                             "  \"x\": 5\n"
+                                             "}"};
+            EXPECT_EQ(expected_text, response.text);
+            EXPECT_EQ(url, response.url);
+            EXPECT_EQ(std::string{"application/json"}, response.header["content-type"]);
+            EXPECT_EQ(201, response.status_code);
+            EXPECT_EQ(ErrorCode::OK, response.error.code);
+        }
+    }
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    ::testing::AddGlobalTestEnvironment(server);
+    return RUN_ALL_TESTS();
+}
diff --git a/cpr/test/util_tests.cpp b/cpr/test/util_tests.cpp
new file mode 100644
index 0000000..637d2f2
--- /dev/null
+++ b/cpr/test/util_tests.cpp
@@ -0,0 +1,78 @@
+#include <gtest/gtest.h>
+
+#include <string>
+
+#include <cpr/cprtypes.h>
+#include <cpr/util.h>
+
+using namespace cpr;
+
+TEST(UtilParseHeaderTests, BasicParseTest) {
+    auto header_string = std::string{
+        "HTTP/1.1 200 OK\r\n"
+        "Server: nginx\r\n"
+        "Date: Sun, 05 Mar 2017 00:34:54 GMT\r\n"
+        "Content-Type: application/json\r\n"
+        "Content-Length: 351\r\n"
+        "Connection: keep-alive\r\n"
+        "Access-Control-Allow-Origin: *\r\n"
+        "Access-Control-Allow-Credentials: true\r\n"
+        "\r\n"};
+    auto header = util::parseHeader(header_string);
+    EXPECT_EQ(std::string{"nginx"}, header["Server"]);
+    EXPECT_EQ(std::string{"Sun, 05 Mar 2017 00:34:54 GMT"}, header["Date"]);
+    EXPECT_EQ(std::string{"application/json"}, header["Content-Type"]);
+    EXPECT_EQ(std::string{"351"}, header["Content-Length"]);
+    EXPECT_EQ(std::string{"keep-alive"}, header["Connection"]);
+    EXPECT_EQ(std::string{"*"}, header["Access-Control-Allow-Origin"]);
+    EXPECT_EQ(std::string{"true"}, header["Access-Control-Allow-Credentials"]);
+}
+
+TEST(UtilParseHeaderTests, NewlineTest) {
+    auto header_string = std::string{
+        "HTTP/1.1 200 OK\r\n"
+        "Auth:\n"
+        "Access-Control-Allow-Credentials: true\r\n"
+        "\r\n"};
+    auto header = util::parseHeader(header_string);
+    EXPECT_EQ(std::string{""}, header["Server"]);
+    EXPECT_EQ(std::string{"true"}, header["Access-Control-Allow-Credentials"]);
+}
+
+TEST(UtilParseHeaderTests, SpaceNewlineTest) {
+    auto header_string = std::string{
+        "HTTP/1.1 200 OK\r\n"
+        "Auth: \n"
+        "Access-Control-Allow-Credentials: true\r\n"
+        "\r\n"};
+    auto header = util::parseHeader(header_string);
+    EXPECT_EQ(std::string{""}, header["Server"]);
+    EXPECT_EQ(std::string{"true"}, header["Access-Control-Allow-Credentials"]);
+}
+
+TEST(UtilParseHeaderTests, CarriageReturnNewlineTest) {
+    auto header_string = std::string{
+        "HTTP/1.1 200 OK\n"
+        "Auth:\r\n"
+        "Access-Control-Allow-Credentials: true\r\n"
+        "\r\n"};
+    auto header = util::parseHeader(header_string);
+    EXPECT_EQ(std::string{""}, header["Server"]);
+    EXPECT_EQ(std::string{"true"}, header["Access-Control-Allow-Credentials"]);
+}
+
+TEST(UtilParseHeaderTests, SpaceCarriageReturnNewlineTest) {
+    auto header_string = std::string{
+        "HTTP/1.1 200 OK\n"
+        "Auth: \r\n"
+        "Access-Control-Allow-Credentials: true\r\n"
+        "\r\n"};
+    auto header = util::parseHeader(header_string);
+    EXPECT_EQ(std::string{""}, header["Server"]);
+    EXPECT_EQ(std::string{"true"}, header["Access-Control-Allow-Credentials"]);
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    return RUN_ALL_TESTS();
+}
diff --git a/src/cpr_test.cpp b/src/cpr_test.cpp
new file mode 100644
index 0000000..c77017b
--- /dev/null
+++ b/src/cpr_test.cpp
@@ -0,0 +1,9 @@
+#include <cpr/cpr.h>
+#include <iostream>
+
+int main(int argc, char** argv) {
+    auto r = cpr::Get(cpr::Url{"https://192.168.1.103/redfish/v1"},cpr::VerifySsl{false});
+    std::cout << r.status_code << std::endl;                  // 200
+    std::cout << r.header["content-type"] << std::endl;       // application/json; charset=utf-8
+    std::cout << r.text << std::endl;                         // JSON text string
+}
-- 
2.17.1

